#include "stdafx.h"

#include "CampathDrawer.h"

#include "hlaeFolder.h"

#include <shared/MirvCampath.h>

#include "../shaders/build/afx_line_ps20.h" // autogenerated
#include "../shaders/build/afx_line_vs20.h" // autogenerated
#include "../shaders/build/afx_drawtexture_ps20.h" // autogenerated

#define _USE_MATH_DEFINES
#include <math.h>

#include <stdio.h>
#include <string>

/// <remarks>Must be at least 4.</remarks>
const UINT c_VertexBufferVertexCount = 200;

const FLOAT c_CampathCrossRadius = 36.0f;
const FLOAT c_CampathCrossPixelWidth = 4.0f;

const FLOAT c_CameraRadius = c_CampathCrossRadius / 2.0f;
const FLOAT c_CameraPixelWidth = 4.0f;

const FLOAT c_CameraTrajectoryPixelWidth = 8.0f;

/// <summary>Epsilon for point reduction in world units (inch).</summary>
/// <remarks>Must be at least 0.0.</remarks>
const double c_CameraTrajectoryEpsilon = 1.0f;

/// <remarks>Must be at least 2.</remarks>
const size_t c_CameraTrajectoryMaxPointsPerInterval = 1024;

CCampathDrawer g_CampathDrawer;


extern CamPath g_CamPath;


struct AFXDRAWTEXTUREVERTEX
{
	float    pos[3];
	float    uv[2];
};
#define D3DFVF_AFXDRAWTEXTUREVERTEX (D3DFVF_XYZ|D3DFVF_TEX1|D3DFVF_TEXCOORDSIZE1(1))


// CCampathDrawer //////////////////////////////////////////////////////////////

CCampathDrawer::CCampathDrawer()
: m_Draw(false)
, m_VertexBuffer(nullptr)
, m_VertexBufferVertexCount(0)
, m_LockedVertexBuffer(nullptr)
{
	m_Device = nullptr;
	m_PixelShader = nullptr;
	m_VertexShader = nullptr;
}

CCampathDrawer::~CCampathDrawer()
{
	if (m_DrawTextureShader) m_DrawTextureShader->Release();
	if(m_PixelShader) m_PixelShader->Release();
	if(m_VertexShader) m_VertexShader->Release();
	if(m_LessDynamicProperties) m_LessDynamicProperties->Release();
}

void CCampathDrawer::AutoPolyLineStart()
{
	m_PolyLineStarted = true;
}

void CCampathDrawer::AutoPolyLinePoint(Vector3 previous, Vector3 current, DWORD colorCurrent, Vector3 next)
{
	// make sure we have enough space:
	if(c_VertexBufferVertexCount < m_VertexBufferVertexCount+2)
		AutoPolyLineFlush();

	bool isFirst = 0 == m_VertexBufferVertexCount;

	if(!m_LockedVertexBuffer)
	{
		bool locked = LockVertexBuffer();
		if(!locked)
			return;
	}

	Vertex * curBuf = &(m_LockedVertexBuffer[m_VertexBufferVertexCount]);
	if(isFirst && !m_PolyLineStarted)
	{
		BuildPolyLinePoint(m_OldPreviousPolyLinePoint, previous, m_OldCurrentColor, current, curBuf);
		curBuf += 2;
		m_VertexBufferVertexCount += 2;
	}

	BuildPolyLinePoint(previous, current, colorCurrent, next, curBuf);
	m_VertexBufferVertexCount += 2;

	m_PolyLineStarted = false;
	m_OldCurrentColor = colorCurrent;
	m_OldPreviousPolyLinePoint = previous;
}

void CCampathDrawer::AutoPolyLineFlush()
{
	if(!m_LockedVertexBuffer)
		return;

	UnlockVertexBuffer();

    UINT stride = sizeof(Vertex);
    UINT offset = 0;
    m_DeviceContext->IASetVertexBuffers(0, 1, &m_VertexBuffer, &stride, &offset);

	UINT startVertex = 0;
	UINT primitiveCount = m_VertexBufferVertexCount -2;

	// Draw lines:
	m_DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
	m_DeviceContext->Draw(m_VertexBufferVertexCount, startVertex);
	startVertex += 2*(primitiveCount+1);

	m_VertexBufferVertexCount = 0;
}

void CCampathDrawer::AutoSingleLine(Vector3 from, DWORD colorFrom, Vector3 to, DWORD colorTo)
{
	// make sure we have space for another line:
	if(c_VertexBufferVertexCount < m_VertexBufferVertexCount+4)
		AutoSingleLineFlush();

	if(!m_LockedVertexBuffer)
	{
		bool locked = LockVertexBuffer();
		if(!locked)
			return;
	}

	Vertex * curBuf = &(m_LockedVertexBuffer[m_VertexBufferVertexCount]);
	BuildSingleLine(from, to, curBuf);
	BuildSingleLine(colorFrom, colorTo, curBuf);
	m_VertexBufferVertexCount += 4;
}

void CCampathDrawer::AutoSingleLineFlush()
{
	if(!m_LockedVertexBuffer)
		return;

	UnlockVertexBuffer();

    UINT stride = sizeof(Vertex);
    UINT offset = 0;
    m_DeviceContext->IASetVertexBuffers(0, 1, &m_VertexBuffer, &stride, &offset);

	UINT startVertex = 0;
	UINT lineCount = m_VertexBufferVertexCount / 4;
	for(UINT i=0; i<lineCount; ++i)
	{
		// Draw line:
		m_DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
		m_DeviceContext->Draw(4, startVertex);		

		startVertex += 4;
	}

	m_VertexBufferVertexCount = 0;
}

void CCampathDrawer::BeginDevice(ID3D11Device * device)
{
	EndDevice();

	if(0 == device)
		return;

	device->AddRef();

	m_Device = device;
	m_Device->CreateDeferredContext(0,&m_DeviceContext);

	{	
		D3D11_BUFFER_DESC cbDesc;
		cbDesc.ByteWidth = sizeof( VS_CONSTANT_BUFFER_VIEWPLANES );
		cbDesc.Usage = D3D11_USAGE_DYNAMIC;
		cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		cbDesc.MiscFlags = 0;
		cbDesc.StructureByteStride = 0;

		m_Device->CreateBuffer(
			&cbDesc, NULL, &m_BufferViewPlanes
		);
	}

	{	
		D3D11_BUFFER_DESC cbDesc;
		cbDesc.ByteWidth = sizeof( VS_CONSTANT_BUFFER_WORLDRTOSCREEN );
		cbDesc.Usage = D3D11_USAGE_DYNAMIC;
		cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		cbDesc.MiscFlags = 0;
		cbDesc.StructureByteStride = 0;

		m_Device->CreateBuffer(
			&cbDesc, NULL, &m_BufferWorldToScreen
		);
	}

	{	
		D3D11_BUFFER_DESC cbDesc;
		cbDesc.ByteWidth = sizeof( VS_CONSTANT_BUFFER_SCREENINFO );
		cbDesc.Usage = D3D11_USAGE_DYNAMIC;
		cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		cbDesc.MiscFlags = 0;
		cbDesc.StructureByteStride = 0;

		m_Device->CreateBuffer(
			&cbDesc, NULL, &m_BufferScreenInfo
		);
	}
}

void CCampathDrawer::BuildPolyLinePoint(Vector3 previous, Vector3 current, DWORD currentColor, Vector3 next, Vertex * pOutVertexData)
{
	Vector3 toPrevious = (previous-current).Normalize();
	Vector3 toNext = (next-current).Normalize();
	double lengthPrevious = (previous-current).Length()/8192;
	double lengthNext = (next-current).Length()/8192;
	
	pOutVertexData[1].x = pOutVertexData[0].x = (float)current.X;
	pOutVertexData[1].y = pOutVertexData[0].y = (float)current.Y;
	pOutVertexData[1].z = pOutVertexData[0].z = (float)current.Z;

	pOutVertexData[3].t1u = pOutVertexData[2].t1u = pOutVertexData[1].t1u = pOutVertexData[0].t1u = (float)toPrevious.X;
	pOutVertexData[3].t1v = pOutVertexData[2].t1v = pOutVertexData[1].t1v = pOutVertexData[0].t1v = (float)toPrevious.Y;
	pOutVertexData[3].t1w = pOutVertexData[2].t1w = pOutVertexData[1].t1w = pOutVertexData[0].t1w = (float)toPrevious.Z;

	pOutVertexData[3].t2u = pOutVertexData[2].t2u = pOutVertexData[1].t2u = pOutVertexData[0].t2u = (float)toNext.X;
	pOutVertexData[3].t2v = pOutVertexData[2].t2v = pOutVertexData[1].t2v = pOutVertexData[0].t2v = (float)toNext.Y;
	pOutVertexData[3].t2w = pOutVertexData[2].t2w = pOutVertexData[1].t2w = pOutVertexData[0].t2w = (float)toNext.Z;

	pOutVertexData[0].t0u = 1.0f;
	pOutVertexData[1].t0u = -1.0f;

	pOutVertexData[1].t0v = pOutVertexData[0].t0v = (float)lengthPrevious;
	pOutVertexData[1].t0w = pOutVertexData[0].t0w = (float)lengthNext;

	pOutVertexData[1].diffuse = pOutVertexData[0].diffuse = currentColor;
}

void CCampathDrawer::CamPathChanged(CamPath * obj)
{
	if(m_LessDynamicProperties) {
		m_LessDynamicProperties->Release();
	}
	m_LessDynamicProperties = new CLessDynamicProperties(this);
	m_LessDynamicProperties->AddRef();
}

void CCampathDrawer::Draw_set(bool value)
{
	m_Draw = value;
}

bool CCampathDrawer::Draw_get(void)
{
	return m_Draw;
}

void CCampathDrawer::EndDevice()
{
	if(0 == m_Device)
		return;

	UnloadVertexBuffer();

	if(m_BufferScreenInfo) {
		m_BufferScreenInfo->Release();
		m_BufferScreenInfo = nullptr;
	}

	if(m_BufferWorldToScreen) {
		m_BufferWorldToScreen->Release();
		m_BufferWorldToScreen = nullptr;
	}

	if(m_BufferViewPlanes) {
		m_BufferViewPlanes->Release();
		m_BufferViewPlanes = nullptr;
	}

	if(m_DeviceContext) {
		m_DeviceContext->Release();
		m_DeviceContext = nullptr;
	}

	m_Device->Release();
	m_Device = 0;
}

void CCampathDrawer::Begin() {
	g_CamPath.OnChanged_set(this);
	CamPathChanged(&g_CamPath);
}

void CCampathDrawer::End() {
	g_CamPath.OnChanged_set(nullptr);
}

#define ValToUCCondInv(value,invert) ((invert) ? 0xFF -(unsigned char)(value) : (unsigned char)(value) )

CCampathDrawer::CDynamicProperties::CDynamicProperties(CCampathDrawer * drawer) {
	m_CurTime = g_MirvTime.GetTime() - g_CamPath.GetOffset();
	m_InCampath = 1 <= g_CamPath.GetSize()
		&&	g_CamPath.GetLowerBound() <= m_CurTime
		&& m_CurTime <= g_CamPath.GetUpperBound();
	m_CampathEnabled = g_CamPath.Enabled_get();

	g_VEngineClient->GetScreenSize(m_ScreenWidth, m_ScreenHeight);

	m_WorldToScreenMatrix = g_VEngineClient->WorldToScreenMatrix();

	// Provide view plane info for line clipping:
	double plane0[4] = { 0,0,0,1 };
	double planeN[4] = { 1,0,0,1 };
	double planeR[4] = { 0,-1,0,1 };
	double planeU[4] = { 0,0,1,1 };
	{

		unsigned char P[4];
		unsigned char Q[4];

		double L[4][4];
		double U[4][4];

		double M[4][4] = {
			m_WorldToScreenMatrix.m[0][0], m_WorldToScreenMatrix.m[0][1], m_WorldToScreenMatrix.m[0][2], 0,
			m_WorldToScreenMatrix.m[1][0], m_WorldToScreenMatrix.m[1][1], m_WorldToScreenMatrix.m[1][2], 0,
			m_WorldToScreenMatrix.m[2][0], m_WorldToScreenMatrix.m[2][1], m_WorldToScreenMatrix.m[2][2], 0,
			m_WorldToScreenMatrix.m[3][0], m_WorldToScreenMatrix.m[3][1], m_WorldToScreenMatrix.m[3][2], -1,
		};

		double b0[4] = {
			0 - m_WorldToScreenMatrix.m[0][3],
			0 - m_WorldToScreenMatrix.m[1][3],
			0 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};

		double bN[4] = {
			0 - m_WorldToScreenMatrix.m[0][3],
			0 - m_WorldToScreenMatrix.m[1][3],
			1 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};
		double bR[4] = {
			1 - m_WorldToScreenMatrix.m[0][3],
			0 - m_WorldToScreenMatrix.m[1][3],
			0 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};

		double bU[4] = {
			0 - m_WorldToScreenMatrix.m[0][3],
			1 - m_WorldToScreenMatrix.m[1][3],
			0 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};
		if (!LUdecomposition(M, P, Q, L, U))
		{
			advancedfx::Warning("AFXERROR in CCampathDrawer::OnPostRenderAllTools: LUdecomposition failed\n");
		}
		else
		{
			SolveWithLU(L, U, P, Q, b0, plane0);
			SolveWithLU(L, U, P, Q, bN, planeN);

			SolveWithLU(L, U, P, Q, bR, planeR);
			SolveWithLU(L, U, P, Q, bU, planeU);
		}

		/*
		vvPos = Vector3(plane0[0], plane0[1], plane0[2]);
		vvForward = Vector3(planeN[0] -vvPos.X, planeN[1] -vvPos.Y, planeN[2]-vvPos.Z);
		vvForward.Normalize();
		vvRight = Vector3(planeR[0] -vvPos.X, planeR[1] -vvPos.Y, planeR[2]-vvPos.Z);
		vvRight.Normalize();
		vvUp = Vector3(planeU[0] -vvPos.X, planeU[1] -vvPos.Y, planeU[2]-vvPos.Z);
		vvUp.Normalize();
		*/

		/*
		Tier0_Msg("CCampathDrawer::OnPostRenderAllTools: curTime = %f\n",curTime);
		Tier0_Msg("M[0]=%f %f %f %f\nM[1]=%f %f %f %f\nM[2]=%f %f %f %f\nM[3]=%f %f %f %f\n", M[0][0],M[0][1],M[0][2],M[0][3], M[1][0],M[1][1],M[1][2],M[1][3], M[2][0],M[2][1],M[2][2],M[2][3], M[3][0],M[3][1],M[3][2],M[3][3]);
		Tier0_Msg("b0[0]=%f %f %f %f\n", b0[0], b0[1], b0[2], b0[3]);
		Tier0_Msg("bN[0]=%f %f %f %f\n", bN[0], bN[1], bN[2], bN[3]);
		Tier0_Msg("plane0=%f %f %f %f\n", plane0[0], plane0[1], plane0[2], plane0[3]);
		Tier0_Msg("planeN=%f %f %f %f\n", planeN[0], planeN[1], planeN[2], planeN[3]);
		*/

		m_PlaneOrigin = Vector3(plane0[0],plane0[1],plane0[2]);
		
		m_PlaneNormal = Vector3(planeN[0] - plane0[0], planeN[1] - plane0[1], planeN[2] - plane0[2]); 
		m_PlaneNormal.Normalize();

		m_PlaneRight = Vector3(planeR[0] - plane0[0], planeR[1] - plane0[1], planeR[2] - plane0[2]);
		m_PlaneRight.Normalize();

		m_PlaneUp = Vector3(planeU[0] - plane0[0], planeU[1] - plane0[1], planeU[2] - plane0[2]);
		m_PlaneUp.Normalize();		
	}

	m_DrawKeyFrameIndex = drawer->m_DrawKeyframIndex;
	m_DrawKeyframeAxis = drawer->m_DrawKeyframeAxis;
	m_DrawKeyframeCam = drawer->m_DrawKeyframeCam;

	if(g_CamPath.CanEval() && 2 <= g_CamPath.GetSize()) {
		m_CurrentValue = g_CamPath.Eval(m_CurTime);
	}
}

CCampathDrawer::CLessDynamicProperties::CLessDynamicProperties(CCampathDrawer * drawer) {

	m_CampathCanEval = g_CamPath.CanEval();

	for (CamPathIterator it = g_CamPath.GetBegin(); it != g_CamPath.GetEnd(); ++it)
	{
		m_Keyframes.emplace_back(it.GetTime(), it.GetValue());
	}

	if(m_CampathCanEval && 2 <= m_Keyframes.size()) {
		// Build trajectory points.
		// This operation can be quite expensive (up to O(N^2)),
		// so it should be done only when s.th.
		// changed (which is what we do here).

		auto last = g_CamPath.GetBegin();
		auto it = last;

		TempPoint * pts = new TempPoint[c_CameraTrajectoryMaxPointsPerInterval];

		for(++it; it != g_CamPath.GetEnd(); ++it)
		{
			double delta = it.GetTime() - last.GetTime();

			for(size_t i = 0; i<c_CameraTrajectoryMaxPointsPerInterval; i++)
			{
				double t = last.GetTime() + delta*((double)i/(c_CameraTrajectoryMaxPointsPerInterval-1));

				CamPathValue cpv = g_CamPath.Eval(t);

				pts[i].t = t;
				pts[i].y = Vector3(cpv.X, cpv.Y, cpv.Z);
				pts[i].nextPt = i+1 <c_CameraTrajectoryMaxPointsPerInterval ? &(pts[i+1]) : 0;
			}

			RamerDouglasPeucker(&(pts[0]), &(pts[c_CameraTrajectoryMaxPointsPerInterval-1]), c_CameraTrajectoryEpsilon);

			// add all points except the last one (to avoid duplicates):
			for(TempPoint * pt = &(pts[0]); pt && pt->nextPt; pt = pt->nextPt)
			{
				m_TrajectoryPoints.emplace_back(
					pt->t,
					g_CamPath.Eval(pt->t));
			}

			last = it;
		}

		// add last point:
		m_TrajectoryPoints.emplace_back(
			pts[c_CameraTrajectoryMaxPointsPerInterval-1].t,
			g_CamPath.Eval(pts[c_CameraTrajectoryMaxPointsPerInterval-1].t));

		delete[] pts;
	}
}

void CCampathDrawer::CCampathDrawerFunctor::operator()() {
	g_CampathDrawer.OnPostRenderAllTools_DrawingThread(m_DynamicProperties, m_LessDynamicProperties);
}

void CCampathDrawer::OnPostRenderAllTools_EngineThread() {
	// Actually we are often called twice per frame , once after 3d skybox
	// and once after world is drawn, maybe we will be even called more times.

	if(!m_Draw || nullptr == m_LessDynamicProperties)
		return;
	
	MaterialSystem_ExecuteOnRenderThread(new CCampathDrawerFunctor(this));
}

void CCampathDrawer::SetNewScreenInfo(FLOAT * newScreenInfo) {
	VS_CONSTANT_BUFFER_SCREENINFO screenInfo = {
		{ newScreenInfo[0],newScreenInfo[1],newScreenInfo[2],newScreenInfo[3] }
	};
	{
		D3D11_MAPPED_SUBRESOURCE mappedResource;
		m_DeviceContext->Map(m_BufferScreenInfo, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
		memcpy(mappedResource.pData, &screenInfo, sizeof(screenInfo));
		m_DeviceContext->Unmap(m_BufferScreenInfo, 0);
		m_DeviceContext->VSSetConstantBuffers(8,1,&m_BufferScreenInfo);
	}
}

void CCampathDrawer::OnPostRenderAllTools_DrawingThread(CDynamicProperties * dynamicPorperties, CLessDynamicProperties * lessDynamicProperties)
{
	if(!m_VertexShader)
	{
		m_VertexShader = g_AfxShaders.GetAcsVertexShader(L"afx_line_vs20.acs", ShaderCombo_afx_line_vs20::GetCombo());
	}
	ID3D11VertexShader * vertexShader = m_VertexShader->GetVertexShader();

	if(!m_PixelShader)
	{
		m_PixelShader = g_AfxShaders.GetAcsPixelShader(L"afx_line_ps20.acs", ShaderCombo_afx_line_ps20::GetCombo());
	}
	ID3D11PixelShader * pixelShader = m_PixelShader->GetPixelShader();

	if (!m_DrawTextureShader)
	{
		m_DrawTextureShader = g_AfxShaders.GetAcsPixelShader(L"afx_drawtexture_ps20.acs", ShaderCombo_afx_drawtexture_ps20::GetCombo());
	}

	if(!(m_Device
		&& m_DeviceContext 
		&& vertexShader && pixelShader
		&& m_BufferViewPlanes
		&& m_BufferWorldToScreen
		&& m_BufferScreenInfo))
	{
		static bool firstError = true;

		if(firstError)
		{
			firstError = false;
			advancedfx::Warning(
				"AFXERROR: CCampathDrawer::OnEndScene: Missing required dependencies:%s%s%s.\n",
				!m_Device ? " m_Device" : "",
				!vertexShader ? " vertexShader" : "",
				!pixelShader ? " pixelShader" : ""
			);
		}

		return;
	}

	// Save device state:

	AfxD3D9BeginCleanState();

	// Draw:
	{
		//Vector3 vvForward, vvUp, vvRight, vvPos;

		double curTime = dynamicPorperties->GetCurTime();
		bool inCampath = dynamicPorperties->GetInCampath();
		bool campathCanEval = lessDynamicProperties->GetCampathCanEval();
		bool campathEnabled = dynamicPorperties->GetCampathEnabled();
		bool cameraMightBeSelected = false;

		int screenWidth = dynamicPorperties->GetScreenWidth();
		int screenHeight = dynamicPorperties->GetScreenHeight();
		FLOAT newCScreenInfo[4] = { 0 != screenWidth ? 1.0f / screenWidth : 0.0f, 0 != screenHeight ? 1.0f / screenHeight : 0.0f, 0.0, 0.0f };

		const SOURCESDK::VMatrix & worldToScreenMatrix = dynamicPorperties->GetWorldToScreenMatrix();

		// Provide view plane info for line clipping:
		{
			const Vector3 & planeOrigin = dynamicPorperties->GetPlaneOrigin();
			const Vector3 & planeNormal = dynamicPorperties->GetPlaneNormal();

			VS_CONSTANT_BUFFER_VIEWPLANES vPlane_0_and_N = {
				{ (float)planeOrigin.X, (float)planeOrigin.Y, (float)planeOrigin.Z, 0.0f },

				{ (float)planeNormal.X, (float)planeNormal.Y, (float)planeNormal.Z, 0.0f }
			};
			{
				D3D11_MAPPED_SUBRESOURCE mappedResource;
				m_DeviceContext->Map(m_BufferViewPlanes, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
				memcpy(mappedResource.pData, &vPlane_0_and_N, sizeof(vPlane_0_and_N));
				m_DeviceContext->Unmap(m_BufferViewPlanes, 0);
				m_DeviceContext->VSSetConstantBuffers(49,1,&m_BufferViewPlanes);
			}
		}

		// Draw keyframes index:
		float drawKeyFrameIndex = dynamicPorperties->GetDrawKeyframeIndex();
		if (drawKeyFrameIndex) {
			if (nullptr == m_DigitsTexture)			
			{
				void * pImageData = malloc(sizeof(unsigned char*)*4*256*128);
				if(pImageData) {
					std::wstring fileName = GetHlaeFolderW();
					fileName += L"resources\\hexfont.tga";

					FILE* file;
					_wfopen_s(&file, fileName.c_str(), L"rb");
					if (file)
					{
						fseek(file, 18, SEEK_SET);

						fread(pImageData,1,4*256*128,file);

						fclose(file);
					}

					D3D11_SUBRESOURCE_DATA subResourceData {
						pImageData,
						sizeof(unsigned char*)*256*4,
						0
					};

					D3D11_TEXTURE2D_DESC textureDesc = {
						256, // width
						128, // height
						1, // MipLevels
						1, // ArraySize,
						DXGI_FORMAT_B8G8R8A8_UNORM, // Format
						{1,0}, // smaple count, sample quality
						D3D11_USAGE_IMMUTABLE, // Usage
						D3D11_BIND_SHADER_RESOURCE, // BindFlags,
						0, // CPUAccessFlags
						0 // MiscFlags
					};

					m_Device->CreateTexture2D(&textureDesc,&subResourceData,&m_DigitsTexture);

					free(pImageData);
				}
			}

			if (m_DigitsTexture)
			{
				if (ID3D11PixelShader* pixelShader = m_DrawTextureShader->GetPixelShader())
				{
					m_Device->SetFVF(D3DFVF_AFXDRAWTEXTUREVERTEX);

					// Setup viewport
					D3DVIEWPORT9 vp;
					vp.X = (DWORD)0;
					vp.Y = (DWORD)0;
					vp.Width = (DWORD)screenWidth;
					vp.Height = (DWORD)screenHeight;
					vp.MinZ = 0.0f;
					vp.MaxZ = 1.0f;
					m_Device->SetViewport(&vp);

					D3D11_DEPTH_STENCIL_DESC depthStencilDesc {
						TRUE, // DepthEnable;
						D3D11_DEPTH_WRITE_MASK_ALL, // DepthWriteMask
						D3D11_COMPARISON_LESS_EQUAL, // DepthFunc
						FALSE, // StencilEnable
						D3D11_DEFAULT_STENCIL_WRITE_MASK, // StencilReadMask
						D3D11_DEFAULT_STENCIL_READ_MASK, // StencilWriteMask
						{ D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // FrontFace
						{ D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // BackFace
					};

					D3D11_RASTERIZER_DESC rasterizerDesc {
						D3D11_FILL_SOLID, // FillMode
						D3D11_CULL_NONE, // CullMode
						TRUE, // FrontCounterClockwise
						0, // DepthBias
						1, // DepthBiasClamp
						1, // SlopeScaledDepthBias
						TRUE, // DepthClipEnable
						FALSE, // ScissorEnable
						TRUE, // MultisampleEnable
						FALSE // AntialiasedLineEnable	
					};

					D3D11_SAMPLER_DESC  samplerDesc{
						D3D11_FILTER_MIN_MAG_MIP_LINEAR, // Filter
						D3D11_TEXTURE_ADDRESS_CLAMP, // AddressU
						D3D11_TEXTURE_ADDRESS_CLAMP, // AddressV
						D3D11_TEXTURE_ADDRESS_WRAP,  // AddressW;
						0, // MipLODBias
						1, // MaxAnisotropy
						D3D11_COMPARISON_ALWAYS, // ComparisonFunc
						{0,0,0,0}, // BorderColor
						-D3D11_FLOAT32_MAX, // MinLOD
						D3D11_FLOAT32_MAX // MaxLOD
					};

					D3D11_BLEND_DESC blendDesc {
						FALSE, // AlphaToCoverageEnable
						FALSE, // IndependentBlendEnable
						// D3D11_RENDER_TARGET_BLEND_DESC
						{
							{
								TRUE, // BlendEnable
								D3D11_BLEND_SRC_ALPHA, // SrcBlend,
								D3D11_BLEND_INV_SRC_ALPHA, // DstBlend
								D3D11_BLEND_OP_ADD, // BlendOp
								D3D11_BLEND_SRC_ALPHA, // SrcBlendAlpha,
								D3D11_BLEND_INV_SRC_ALPHA, // DestBlendAlpha
								D3D11_BLEND_OP_ADD, // BlendOpAlpha
								D3D11_COLOR_WRITE_ENABLE_ALL // RenderTargetWriteMask
							}
							, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
							, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
							, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
							, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
							, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
							, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
							, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
						}
					};

					todo ^^

					m_Device->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);

					m_Device->SetVertexShader(NULL);
					m_Device->SetPixelShader(pixelShader);

					m_Device->SetRenderState(D3DRS_ALPHAREF, (DWORD)0x00000001);
					m_Device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
					m_Device->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL);

					m_Device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
					m_Device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
					m_Device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
					m_Device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
					m_Device->SetSamplerState(0, D3DSAMP_SRGBTEXTURE, FALSE);

					// texture:
					m_Device->SetTexture(0, m_DigitsTexture);


					// Setup projection matrix
					{
						D3DMATRIX mat_identity = { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } };
						D3DMATRIX mat_projection =
						{
							worldToScreenMatrix.m[0][0], worldToScreenMatrix.m[1][0], worldToScreenMatrix.m[2][0], worldToScreenMatrix.m[3][0],
							worldToScreenMatrix.m[0][1], worldToScreenMatrix.m[1][1], worldToScreenMatrix.m[2][1], worldToScreenMatrix.m[3][1],
							worldToScreenMatrix.m[0][2], worldToScreenMatrix.m[1][2], worldToScreenMatrix.m[2][2], worldToScreenMatrix.m[3][2],
							worldToScreenMatrix.m[0][3], worldToScreenMatrix.m[1][3], worldToScreenMatrix.m[2][3], worldToScreenMatrix.m[3][3]
						};
						m_Device->SetTransform(D3DTS_WORLD, &mat_identity);
						m_Device->SetTransform(D3DTS_VIEW, &mat_identity);
						m_Device->SetTransform(D3DTS_PROJECTION, &mat_projection);
					}

					int index = 0;

					const Vector3 & vvRight = dynamicPorperties->GetPlaneRight();
					const Vector3 & vvUp = dynamicPorperties->GetPlaneUp();

					for (auto it = lessDynamicProperties->GetKeyframesBegin(); it != lessDynamicProperties->GetKeyframesEnd(); it++)
					{
						int digits = 0;
						for (int t = index; 0 < t; t = t / 10)
						{
							++digits;
						}
						if (digits < 1) digits = 1;

						double cpT = it->GetTime();
						CamPathValue cpv = it->GetValue();

						int val = index;

						for (int i = 0; i < digits; ++i)
						{
							int cval = val % 10;
							val = val / 10;

							float left = -0.5f * drawKeyFrameIndex * (i + 1);
							float top = 0.5f * drawKeyFrameIndex;
							float bottom = -0.5f * drawKeyFrameIndex;
							float right = left + 0.5f * drawKeyFrameIndex;

							float tx = (32 * (cval % 8)) / 256.0f;
							float ty = (64 * (cval / 8)) / 128.0f;

							AFXDRAWTEXTUREVERTEX vertexData[4] = {
								{{(float)cpv.X + left * (float)vvRight.X + top * (float)vvUp.X, (float)cpv.Y + left * (float)vvRight.Y + top * (float)vvUp.Y, (float)cpv.Z + left * (float)vvRight.Z + top * (float)vvUp.Z}, {tx, ty }},
								{{(float)cpv.X + left * (float)vvRight.X + bottom * (float)vvUp.X, (float)cpv.Y + left * (float)vvRight.Y + bottom * (float)vvUp.Y, (float)cpv.Z + left * (float)vvRight.Z + bottom * (float)vvUp.Z}, {tx, ty + 64 / 128.0f}},
								{{(float)cpv.X + right * (float)vvRight.X + top * (float)vvUp.X, (float)cpv.Y + right * (float)vvRight.Y + top * (float)vvUp.Y, (float)cpv.Z + right * (float)vvRight.Z + top * (float)vvUp.Z}, {tx + 32 / 256.0f, ty}},
								{{(float)cpv.X + right * (float)vvRight.X + bottom * (float)vvUp.X, (float)cpv.Y + right * (float)vvRight.Y + bottom * (float)vvUp.Y, (float)cpv.Z + right * (float)vvRight.Z + bottom * (float)vvUp.Z}, {tx + 32 / 256.0f, ty + 64 / 128.0f}},
							};

							m_Device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &vertexData, sizeof(AFXDRAWTEXTUREVERTEX));
						}

						// cameraMightBeSelected = cameraMightBeSelected || lpSelected && cpv.Selected && lpTime <= curTime && curTime <= cpT;

						++index;
					}
				}
			}
		}

		m_Device->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);
		m_Device->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
		m_Device->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
		m_Device->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
		m_Device->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
		m_Device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
		m_Device->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
		m_Device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		m_Device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		m_Device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		m_Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
		m_Device->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
		m_Device->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

		m_Device->SetVertexShader(vertexShader);

		VS_CONSTANT_BUFFER_VIEWPLANES world_to_screen_matrix = {
			{
				worldToScreenMatrix.m[0][0], worldToScreenMatrix.m[1][0], worldToScreenMatrix.m[2][0], worldToScreenMatrix.m[3][0],
				worldToScreenMatrix.m[0][1], worldToScreenMatrix.m[1][1], worldToScreenMatrix.m[2][1], worldToScreenMatrix.m[3][1],
				worldToScreenMatrix.m[0][2], worldToScreenMatrix.m[1][2], worldToScreenMatrix.m[2][2], worldToScreenMatrix.m[3][2],
				worldToScreenMatrix.m[0][3], worldToScreenMatrix.m[1][3], worldToScreenMatrix.m[2][3], worldToScreenMatrix.m[3][3]										
			}
		};
		{
			D3D11_MAPPED_SUBRESOURCE mappedResource;
			m_DeviceContext->Map(m_BufferWorldToScreen, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
			memcpy(mappedResource.pData, &world_to_screen_matrix, sizeof(world_to_screen_matrix));
			m_DeviceContext->Unmap(m_BufferWorldToScreen, 0);
			m_DeviceContext->VSSetConstantBuffers(8,1,&m_BufferWorldToScreen);
		}

		m_Device->SetPixelShader(pixelShader);

		m_Device->SetFVF(CCampathDrawer_VertexFVF);

		// Draw trajectory:
		if(2 <= lessDynamicProperties->GetKeyframesSize() && lessDynamicProperties->GetCampathCanEval())
		{
			newCScreenInfo[2] = c_CameraTrajectoryPixelWidth;
			this->SetNewScreenInfo(newCScreenInfo);

			AutoPolyLineStart();

			auto itPts = lessDynamicProperties->GetTrajectoryPointsBegin();

			auto itKeysLast = lessDynamicProperties->GetKeyframesBegin();
			auto itKeysNext = itKeysLast;
			++itKeysNext;

			bool hasLastPt = false;
			bool hasNextPt = false;
			bool hasCurPt = false;
			
			double lastPtTime;
			CamPathValue lastPtValue;
			double curPtTime;
			CamPathValue curPtValue;
			double nextPtTime;
			CamPathValue nextPtValue;

			do
			{
				if(hasNextPt)
				{
					hasLastPt = true;
					lastPtTime = curPtTime;
					lastPtValue = curPtValue;

					hasCurPt = true;
					curPtTime = nextPtTime;
					curPtValue = nextPtValue;

					hasNextPt = false;
				}
				else
				{
					hasCurPt = true;
					curPtTime = itPts->GetTime();
					curPtValue = itPts->GetValue();
					++itPts;
				}

				while(itKeysNext->GetTime() < curPtTime)
				{
					itKeysLast = itKeysNext;
					++itKeysNext;
				}

				if(itPts != lessDynamicProperties->GetTrajectoryPointsEnd())
				{
					hasNextPt = true;
					nextPtTime = itPts->GetTime();
					nextPtValue = itPts->GetValue();
					++itPts;
				}
				else
				{
					// current point is last point.
					hasNextPt = false;
					nextPtValue = curPtValue;
				}

				if(!hasLastPt)
				{
					// current point is first point.
					lastPtValue = curPtValue;
				}

				// emit current point:
				{
					double deltaTime = abs(curTime -curPtTime);

					DWORD colour;

					// determine colour:
					if(deltaTime < 1.0)
					{
						double t = (deltaTime -0.0)/1.0;
						colour = D3DCOLOR_RGBA(
							ValToUCCondInv(255.0*t, curPtValue.Selected),
							ValToUCCondInv(255, curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							(unsigned char)(127*(1.0-t))+128
						);
					}
					else
					if(deltaTime < 2.0)
					{
						double t = (deltaTime -1.0)/1.0;
						colour = D3DCOLOR_RGBA(
							ValToUCCondInv(255, curPtValue.Selected),
							ValToUCCondInv(255.0*(1.0-t), curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							(unsigned char)(64*(1.0-t))+64
						);
					}
					else
					{
						colour = D3DCOLOR_RGBA(
							ValToUCCondInv(255, curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							64
						);
					}

					AutoPolyLinePoint(
						Vector3(lastPtValue.X,lastPtValue.Y,lastPtValue.Z)
						, Vector3(curPtValue.X,curPtValue.Y,curPtValue.Z)
						, colour
						, Vector3(nextPtValue.X,nextPtValue.Y,nextPtValue.Z));
				}
			}
			while(hasNextPt);

			AutoPolyLineFlush();
		}

		// Draw keyframes:
		{
			newCScreenInfo[2] = c_CampathCrossPixelWidth;
			this->SetNewScreenInfo(newCScreenInfo);

			bool lpSelected = false;
			double lpTime;
			
			for(auto it = lessDynamicProperties->GetKeyframesBegin(); it != lessDynamicProperties->GetKeyframesEnd(); it++)
			{
				double cpT = it->GetTime();
				CamPathValue cpv = it->GetValue();

				cameraMightBeSelected = cameraMightBeSelected || lpSelected && cpv.Selected && lpTime <= curTime && curTime <= cpT;

				lpSelected = cpv.Selected;
				lpTime = cpT;

				double deltaTime = abs(curTime -cpT);

				bool selected = cpv.Selected;

				DWORD colour;

				// determine colour:
				if(deltaTime < 1.0)
				{
					double t = (deltaTime -0.0)/1.0;
					colour = D3DCOLOR_RGBA(
						ValToUCCondInv(255.0*t, selected),
						ValToUCCondInv(255, selected),
						ValToUCCondInv(0, selected),
						(unsigned char)(127*(1.0-t))+128
					);
				}
				else
				if(deltaTime < 2.0)
				{
					double t = (deltaTime -1.0)/1.0;
					colour = D3DCOLOR_RGBA(
						ValToUCCondInv(255, selected),
						ValToUCCondInv(255.0*(1.0-t), selected),
						ValToUCCondInv(0, selected),
						(unsigned char)(64*(1.0-t))+64
					);
				}
				else
				{
					colour = D3DCOLOR_RGBA(
						ValToUCCondInv(255, selected),
						ValToUCCondInv(0, selected),
						ValToUCCondInv(0, selected),
						64
					);
				}

				if (dynamicPorperties->GetDrawKeyframeAxis())
				{
					// x / forward line:

					AutoSingleLine(
						Vector3(cpv.X - c_CampathCrossRadius, cpv.Y, cpv.Z),
						colour,
						Vector3(cpv.X + c_CampathCrossRadius, cpv.Y, cpv.Z),
						colour
					);

					// y / left line:

					AutoSingleLine(
						Vector3(cpv.X, cpv.Y - c_CampathCrossRadius, cpv.Z),
						colour,
						Vector3(cpv.X, cpv.Y + c_CampathCrossRadius, cpv.Z),
						colour
					);

					// z / up line:

					AutoSingleLine(
						Vector3(cpv.X, cpv.Y, cpv.Z - c_CampathCrossRadius),
						colour,
						Vector3(cpv.X, cpv.Y, cpv.Z + c_CampathCrossRadius),
						colour
					);
				}

				if(dynamicPorperties->GetDrawKeyframeCam()) DrawCamera(cpv, colour, newCScreenInfo, dynamicPorperties->GetScreenWidth(), dynamicPorperties->GetScreenHeight(), dynamicPorperties->GetScreenWidth(), dynamicPorperties->GetScreenHeight());
			}

			AutoSingleLineFlush();
		}

		// Draw wireframe camera:
		if(dynamicPorperties->GetInCampath() && lessDynamicProperties->GetCampathCanEval())
		{
			DWORD colourCam = dynamicPorperties->GetCampathEnabled()
				? D3DCOLOR_RGBA(
					ValToUCCondInv(255,cameraMightBeSelected),
					ValToUCCondInv(0,cameraMightBeSelected),
					ValToUCCondInv(255,cameraMightBeSelected),
					128)
				: D3DCOLOR_RGBA(
					ValToUCCondInv(255,cameraMightBeSelected),
					ValToUCCondInv(255,cameraMightBeSelected),
					ValToUCCondInv(255,cameraMightBeSelected),
					128);

			CamPathValue cpv = dynamicPorperties->GetCurrentValue();

			DrawCamera(cpv, colourCam, newCScreenInfo);
		}
	}

	// Restore device state:

	AfxD3D9EndCleanState();
}

void CCampathDrawer::DrawCamera(const CamPathValue & cpv, DWORD colour, FLOAT screenInfo[4], int screenWidth, int screenHeight)
{
	screenInfo[2] = c_CameraPixelWidth;
	this->SetNewScreenInfo(screenInfo);

	// limit to values as RenderView hook:
	double fov = min(179, max(1, cpv.Fov));

	double forward[3], right[3], up[3];
	QEulerAngles ang = cpv.R.ToQREulerAngles().ToQEulerAngles();
	MakeVectors(ang.Roll, ang.Pitch, ang.Yaw, forward, right, up);

	Vector3 vCp(cpv.X, cpv.Y, cpv.Z);
	Vector3 vForward(forward);
	Vector3 vUp(up);
	Vector3 vRight(right);

	double a = sin(fov * M_PI / 360.0) * c_CameraRadius;
	double b = a;

	double aspectRatio = screenWidth ? (double)screenHeight / (double)screenWidth : 1.0;

	b *= aspectRatio;

	Vector3 vLU = vCp + (double)c_CameraRadius * vForward - a * vRight + b * vUp;
	Vector3 vRU = vCp + (double)c_CameraRadius * vForward + a * vRight + b * vUp;
	Vector3 vLD = vCp + (double)c_CameraRadius * vForward - a * vRight - b * vUp;
	Vector3 vRD = vCp + (double)c_CameraRadius * vForward + a * vRight - b * vUp;
	Vector3 vMU = vLU + (vRU - vLU) / 2;
	Vector3 vMUU = vMU + 0.5 * b * vUp;

	AutoSingleLine(vCp, colour, vLD, colour);

	AutoSingleLine(vCp, colour, vRD, colour);

	AutoSingleLine(vCp, colour, vLU, colour);

	AutoSingleLine(vCp, colour, vRU, colour);

	AutoSingleLine(vLD, colour, vRD, colour);

	AutoSingleLine(vRD, colour, vRU, colour);

	AutoSingleLine(vRU, colour, vLU, colour);

	AutoSingleLine(vLU, colour, vLD, colour);

	AutoSingleLine(vLU, colour, vMUU, colour);

	AutoSingleLine(vRU, colour, vMUU, colour);

	AutoSingleLineFlush();
}

void CCampathDrawer::BuildSingleLine(Vector3 from, Vector3 to, Vertex * pOutVertexData)
{
	Vector3 normal = (to-from).Normalize();
	double length = (to-from).Length() / 8192;
	
	pOutVertexData[1].x = pOutVertexData[0].x = (float)from.X;
	pOutVertexData[3].x = pOutVertexData[2].x = (float)to.X;
	pOutVertexData[1].y = pOutVertexData[0].y = (float)from.Y;
	pOutVertexData[3].y = pOutVertexData[2].y = (float)to.Y;
	pOutVertexData[1].z = pOutVertexData[0].z = (float)from.Z;
	pOutVertexData[3].z = pOutVertexData[2].z = (float)to.Z;

	pOutVertexData[3].t1u = pOutVertexData[2].t1u = pOutVertexData[1].t1u = pOutVertexData[0].t1u = (float)-normal.X;
	pOutVertexData[3].t1v = pOutVertexData[2].t1v = pOutVertexData[1].t1v = pOutVertexData[0].t1v = (float)-normal.Y;
	pOutVertexData[3].t1w = pOutVertexData[2].t1w = pOutVertexData[1].t1w = pOutVertexData[0].t1w = (float)-normal.Z;

	pOutVertexData[3].t2u = pOutVertexData[2].t2u = pOutVertexData[1].t2u = pOutVertexData[0].t2u = (float)normal.X;
	pOutVertexData[3].t2v = pOutVertexData[2].t2v = pOutVertexData[1].t2v = pOutVertexData[0].t2v = (float)normal.Y;
	pOutVertexData[3].t2w = pOutVertexData[2].t2w = pOutVertexData[1].t2w = pOutVertexData[0].t2w = (float)normal.Z;

	pOutVertexData[2].t0u = pOutVertexData[0].t0u = 1.0f;
	pOutVertexData[3].t0u = pOutVertexData[1].t0u = -1.0f;

	pOutVertexData[1].t0v = pOutVertexData[0].t0v = 0.0f;
	pOutVertexData[1].t0w = pOutVertexData[0].t0w = (float)length;
	pOutVertexData[3].t0v = pOutVertexData[2].t0v = (float)length;
	pOutVertexData[3].t0w = pOutVertexData[2].t0w = 0.0f;
}

void CCampathDrawer::BuildSingleLine(DWORD colorFrom, DWORD colorTo, Vertex * pOutVertexData)
{
	pOutVertexData[1].diffuse = pOutVertexData[0].diffuse = colorFrom;
	pOutVertexData[3].diffuse = pOutVertexData[2].diffuse = colorTo;
}

bool CCampathDrawer::LockVertexBuffer()
{
	if(m_VertexBuffer)
	{
		if(!SUCCEEDED(m_VertexBuffer->Lock(0, c_VertexBufferVertexCount * sizeof(Vertex), (void **)&m_LockedVertexBuffer, 0)))
		{
			m_LockedVertexBuffer = 0;
			return false;
		}
		return true;
	}

	UnlockVertexBuffer();

	if(!SUCCEEDED(m_Device->CreateVertexBuffer(
		c_VertexBufferVertexCount * sizeof(Vertex),
		D3DUSAGE_WRITEONLY,
		CCampathDrawer_VertexFVF,
		D3DPOOL_DEFAULT,
		&m_VertexBuffer,
		NULL
	)))
	{
		if(m_VertexBuffer) m_VertexBuffer->Release();
		m_VertexBuffer = 0;
		return false;
	}

	if(m_VertexBuffer)
	{
		if(!SUCCEEDED(m_VertexBuffer->Lock(0, c_VertexBufferVertexCount * sizeof(Vertex), (void **)&m_LockedVertexBuffer, 0)))
		{
			m_LockedVertexBuffer = 0;
			return 0;
		}
		return true;
	}

	return false;
}

void CCampathDrawer::UnlockVertexBuffer()
{
	if(m_VertexBuffer && m_LockedVertexBuffer)
	{
		m_VertexBuffer->Unlock();
		m_LockedVertexBuffer = 0;
	}
}

void CCampathDrawer::UnloadVertexBuffer()
{
	if(m_VertexBuffer) { m_VertexBuffer->Release(); m_VertexBuffer = 0; }
}

void CCampathDrawer::RamerDouglasPeucker(TempPoint * start, TempPoint * end, double epsilon)
{
	double dmax = 0;
	TempPoint * index = start;

	for(TempPoint * i = start->nextPt; i && i != end; i = i->nextPt)
	{
		double d = ShortestDistanceToSegment(i, start, end);
		if(d > dmax)
		{
			index = i;
			dmax = d;
		}
	}

	// If max distance is greater than epsilon, recursively simplify
	if ( dmax > epsilon )
	{
		RamerDouglasPeucker(start, index, epsilon);
		RamerDouglasPeucker(index, end, epsilon);
	} else {
		start->nextPt = end;
	}
}

void CCampathDrawer::Reset()
{
	UnloadVertexBuffer();
	if (m_DigitsTexture)
	{
		m_DigitsTexture->Release();
		m_DigitsTexture = nullptr;
	}
}

double CCampathDrawer::ShortestDistanceToSegment(TempPoint * pt, TempPoint * start, TempPoint * end)
{
	double ESx = end->y.X - start->y.X;
	double ESy = end->y.Y - start->y.Y;
	double ESz = end->y.Z - start->y.Z;
	double dESdES = ESx*ESx + ESy*ESy + ESz*ESz;
	double t = dESdES ? (
		(pt->y.X-start->y.X)*ESx +(pt->y.Y -start->y.Y)*ESy + (pt->y.Z -start->y.Z)*ESz
	) / dESdES : 0.0;

	if(t <= 0.0)
		return (start->y -pt->y).Length();
	else
	if(1.0 <= t)
		return (pt->y -end->y).Length();

	return (pt->y -(start->y +t*(end->y -start->y))).Length();
}
