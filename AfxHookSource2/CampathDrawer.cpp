#include "stdafx.h"

#include "CampathDrawer.h"

#include "hlaeFolder.h"

#include "../shared/MirvCampath.h"

#include "../shaders/build/afx_line_ps_5_0.h" // autogenerated
#include "../shaders/build/afx_line_vs_5_0.h" // autogenerated
#include "../shaders/build/afx_drawtexture_vs_5_0.h" // autogenerated
#include "../shaders/build/afx_drawtexture_ps_5_0.h" // autogenerated

#define _USE_MATH_DEFINES
#include <math.h>

#include <stdio.h>
#include <string>

/// <remarks>Must be at least 4.</remarks>
const UINT c_VertexBufferVertexCount = 200;

const FLOAT c_CampathCrossRadius = 36.0f;
const FLOAT c_CampathCrossPixelWidth = 4.0f;

const FLOAT c_CameraRadius = c_CampathCrossRadius / 2.0f;
const FLOAT c_CameraPixelWidth = 4.0f;

const FLOAT c_CameraTrajectoryPixelWidth = 8.0f;

/// <summary>Epsilon for point reduction in world units (inch).</summary>
/// <remarks>Must be at least 0.0.</remarks>
const double c_CameraTrajectoryEpsilon = 1.0f;

/// <remarks>Must be at least 2.</remarks>
const size_t c_CameraTrajectoryMaxPointsPerInterval = 1024;

CCampathDrawer g_CampathDrawer;


extern CamPath g_CamPath;


#define D3DCOLOR_ARGB(a,r,g,b) \
    ((DWORD)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)


// CCampathDrawer //////////////////////////////////////////////////////////////

CCampathDrawer::CCampathDrawer()
{
}

CCampathDrawer::~CCampathDrawer()
{
	if(m_LessDynamicProperties) m_LessDynamicProperties->Release();
}

void CCampathDrawer::AutoPolyLineStart()
{
	m_PolyLineStarted = true;
}

void CCampathDrawer::AutoPolyLinePoint(Vector3 previous, Vector3 current, DWORD colorCurrent, Vector3 next)
{
	// make sure we have enough space:
	if(c_VertexBufferVertexCount < m_VertexBufferVertexCount+2)
		AutoPolyLineFlush();

	bool isFirst = 0 == m_VertexBufferVertexCount;

	if(!m_LockedVertexBuffer)
	{
		bool locked = LockVertexBuffer();
		if(!locked)
			return;
	}

	Vertex * curBuf = &(m_LockedVertexBuffer[m_VertexBufferVertexCount]);
	if(isFirst && !m_PolyLineStarted)
	{
		BuildPolyLinePoint(m_OldPreviousPolyLinePoint, previous, m_OldCurrentColor, current, curBuf);
		curBuf += 2;
		m_VertexBufferVertexCount += 2;
	}

	BuildPolyLinePoint(previous, current, colorCurrent, next, curBuf);
	m_VertexBufferVertexCount += 2;

	m_PolyLineStarted = false;
	m_OldCurrentColor = colorCurrent;
	m_OldPreviousPolyLinePoint = previous;
}

void CCampathDrawer::AutoPolyLineFlush()
{
	if(!m_LockedVertexBuffer)
		return;

	UnlockVertexBuffer();

    UINT stride = sizeof(Vertex);
    UINT offset = 0;
    m_DeviceContext->IASetVertexBuffers(0, 1, &m_VertexBuffer, &stride, &offset);

	UINT startVertex = 0;
	UINT primitiveCount = m_VertexBufferVertexCount -2;

	// Draw lines:
	m_DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
	m_DeviceContext->Draw(m_VertexBufferVertexCount, startVertex);
	startVertex += 2*(primitiveCount+1);

	m_VertexBufferVertexCount = 0;
}

void CCampathDrawer::AutoSingleLine(Vector3 from, DWORD colorFrom, Vector3 to, DWORD colorTo)
{
	// make sure we have space for another line:
	if(c_VertexBufferVertexCount < m_VertexBufferVertexCount+4)
		AutoSingleLineFlush();

	if(!m_LockedVertexBuffer)
	{
		bool locked = LockVertexBuffer();
		if(!locked)
			return;
	}

	Vertex * curBuf = &(m_LockedVertexBuffer[m_VertexBufferVertexCount]);
	BuildSingleLine(from, to, curBuf);
	BuildSingleLine(colorFrom, colorTo, curBuf);
	m_VertexBufferVertexCount += 4;
}

void CCampathDrawer::AutoSingleLineFlush()
{
	if(!m_LockedVertexBuffer)
		return;

	UnlockVertexBuffer();

    UINT stride = sizeof(Vertex);
    UINT offset = 0;
    m_DeviceContext->IASetVertexBuffers(0, 1, &m_VertexBuffer, &stride, &offset);

	UINT startVertex = 0;
	UINT lineCount = m_VertexBufferVertexCount / 4;
	for(UINT i=0; i<lineCount; ++i)
	{
		// Draw line:
		m_DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
		m_DeviceContext->Draw(4, startVertex);		

		startVertex += 4;
	}

	m_VertexBufferVertexCount = 0;
}

void CCampathDrawer::AutoSingleQuad(Vector3 p0, float t0x, float t0y, Vector3 p1, float t1x, float t1y, Vector3 p2, float t2x, float t2y, Vector3 p3, float t3x, float t3y)
{
	// make sure we have space for another line:
	if(c_VertexBufferVertexCount < m_VertexBufferVertexCount+4)
		AutoSingleLineFlush();

	if(!m_LockedVertexBuffer)
	{
		bool locked = LockVertexBuffer();
		if(!locked)
			return;
	}

	Vertex * curBuf = &(m_LockedVertexBuffer[m_VertexBufferVertexCount]);
	BuildSingleQuad(p0,t0x,t0y,p1,t1x,t1y,p2,t2x,t2y,p3,t3x,t3y,curBuf);
	BuildSingleLine(D3DCOLOR_RGBA(255,255,255,255), D3DCOLOR_RGBA(255,255,255,255), curBuf);
	m_VertexBufferVertexCount += 4;
}

void CCampathDrawer::AutoSingleQuadFlush()
{
	AutoSingleLineFlush();
}

void CCampathDrawer::BeginDevice(ID3D11Device * device)
{
	EndDevice();

	if(nullptr == device)
		return;

	device->AddRef();

	m_Device = device;
	m_Device->CreateDeferredContext(0,&m_DeviceContext);

	{
		size_t size;
		void * so = LoadFromAcsShaderFileInMemory(L"afx_line_vs_5_0.acs", ShaderCombo_afx_line_vs_5_0::GetCombo(), size);

		if(so) {
			m_Device->CreateVertexShader(so, size, NULL, &m_VertexShader);

			D3D11_INPUT_ELEMENT_DESC inputDesc[5] = {
				 {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"COLOR", 0, DXGI_FORMAT_B8G8R8A8_UNORM, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"TEXCOORD", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"TEXCOORD", 1, DXGI_FORMAT_R32G32B32_FLOAT, 0, 28, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"TEXCOORD", 2, DXGI_FORMAT_R32G32B32_FLOAT, 0, 40, D3D11_INPUT_PER_VERTEX_DATA, 0},
			};

			m_Device->CreateInputLayout(inputDesc,5,so,size,&m_InputLayoutLines);
		}
		if(so) free(so);
	}

	{
		size_t size;
		void * so = LoadFromAcsShaderFileInMemory(L"afx_drawtexture_vs_5_0.acs", ShaderCombo_afx_drawtexture_vs_5_0::GetCombo(), size);

		if(so) {
			m_Device->CreateVertexShader(so, size, NULL, &m_DrawTextureVertexShader);

			D3D11_INPUT_ELEMENT_DESC inputDesc[5] = {
				 {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"COLOR", 0, DXGI_FORMAT_B8G8R8A8_UNORM, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"TEXCOORD", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"TEXCOORD", 1, DXGI_FORMAT_R32G32B32_FLOAT, 0, 28, D3D11_INPUT_PER_VERTEX_DATA, 0},
				 {"TEXCOORD", 2, DXGI_FORMAT_R32G32B32_FLOAT, 0, 40, D3D11_INPUT_PER_VERTEX_DATA, 0},
			};

			m_Device->CreateInputLayout(inputDesc,5,so,size,&m_InputLayoutDigits);
		}
		if(so) free(so);
	}	

	{
		size_t size;
		void * so = LoadFromAcsShaderFileInMemory(L"afx_line_ps_5_0.acs", ShaderCombo_afx_line_ps_5_0::GetCombo(), size);

		if(so) {
			m_Device->CreatePixelShader(so,size,NULL,&m_PixelShader);
		}

		if(so) free(so);
	}

	{
		size_t size;
		void * so = LoadFromAcsShaderFileInMemory(L"afx_drawtexture_ps_5_0.acs", ShaderCombo_afx_drawtexture_ps_5_0::GetCombo(), size);

		if(so) {
			m_Device->CreatePixelShader(so,size,NULL,&m_DrawTextureShader);
		}

		if(so) free(so);
	}

	{	
		D3D11_BUFFER_DESC cbDesc;
		cbDesc.ByteWidth = sizeof( VS_CONSTANT_BUFFER );
		cbDesc.Usage = D3D11_USAGE_DYNAMIC;
		cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		cbDesc.MiscFlags = 0;
		cbDesc.StructureByteStride = 0;

		m_Device->CreateBuffer(
			&cbDesc, NULL, &m_ConstantBuffer
		);
	}

	{	
		D3D11_BUFFER_DESC cbDesc;
		cbDesc.ByteWidth = sizeof( VS_CONSTANT_BUFFER_WIDTH );
		cbDesc.Usage = D3D11_USAGE_DYNAMIC;
		cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		cbDesc.MiscFlags = 0;
		cbDesc.StructureByteStride = 0;

		m_Device->CreateBuffer(
			&cbDesc, NULL, &m_ConstantBufferWidth
		);
	}

	{
		D3D11_DEPTH_STENCIL_DESC depthStencilDesc {
			TRUE, // DepthEnable;
			D3D11_DEPTH_WRITE_MASK_ALL, // DepthWriteMask
			D3D11_COMPARISON_LESS_EQUAL, // DepthFunc
			FALSE, // StencilEnable
			D3D11_DEFAULT_STENCIL_WRITE_MASK, // StencilReadMask
			D3D11_DEFAULT_STENCIL_READ_MASK, // StencilWriteMask
			{ D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // FrontFace
			{ D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // BackFace
		};
		m_Device->CreateDepthStencilState(&depthStencilDesc, &m_DepthStencilStateDigits);
	}
	{
		D3D11_DEPTH_STENCIL_DESC depthStencilDesc {
			TRUE, // DepthEnable;
			D3D11_DEPTH_WRITE_MASK_ZERO, // DepthWriteMask
			D3D11_COMPARISON_LESS_EQUAL, // DepthFunc
			FALSE, // StencilEnable
			D3D11_DEFAULT_STENCIL_WRITE_MASK, // StencilReadMask
			D3D11_DEFAULT_STENCIL_READ_MASK, // StencilWriteMask
			{ D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // FrontFace
			{ D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // BackFace
		};		
		m_Device->CreateDepthStencilState(&depthStencilDesc, &m_DepthStencilStateLines);
	}
	{
		D3D11_SAMPLER_DESC  samplerDesc{
			D3D11_FILTER_MIN_MAG_MIP_LINEAR, // Filter
			D3D11_TEXTURE_ADDRESS_CLAMP, // AddressU
			D3D11_TEXTURE_ADDRESS_CLAMP, // AddressV
			D3D11_TEXTURE_ADDRESS_WRAP,  // AddressW;
			0, // MipLODBias
			1, // MaxAnisotropy
			D3D11_COMPARISON_ALWAYS, // ComparisonFunc
			{0,0,0,0}, // BorderColor
			-D3D11_FLOAT32_MAX, // MinLOD
			D3D11_FLOAT32_MAX // MaxLOD
		};
		m_Device->CreateSamplerState(&samplerDesc, &m_SamplerState);
	}
	{
		D3D11_RASTERIZER_DESC rasterizerDesc {
			D3D11_FILL_SOLID, // FillMode
			D3D11_CULL_NONE, // CullMode
			TRUE, // FrontCounterClockwise
			0, // DepthBias
			0, // DepthBiasClamp
			0, // SlopeScaledDepthBias
			TRUE, // DepthClipEnable
			FALSE, // ScissorEnable
			TRUE, // MultisampleEnable
			FALSE // AntialiasedLineEnable	
		};

		m_Device->CreateRasterizerState(&rasterizerDesc, &m_RasterizerStateDigits);
	}
	{

		D3D11_RASTERIZER_DESC rasterizerDesc {
			D3D11_FILL_SOLID, // FillMode
			D3D11_CULL_FRONT, // CullMode
			TRUE, // FrontCounterClockwise
			0, // DepthBias
			0, // DepthBiasClamp
			0, // SlopeScaledDepthBias
			TRUE, // DepthClipEnable
			FALSE, // ScissorEnable
			TRUE, // MultisampleEnable
			FALSE // AntialiasedLineEnable	
		};

		m_Device->CreateRasterizerState(&rasterizerDesc, &m_RasterizerStateLines);
	}
	{
		D3D11_BLEND_DESC blendDesc {
			FALSE, // AlphaToCoverageEnable
			FALSE, // IndependentBlendEnable
			// D3D11_RENDER_TARGET_BLEND_DESC
			{
				{
					TRUE, // BlendEnable
					D3D11_BLEND_SRC_ALPHA, // SrcBlend,
					D3D11_BLEND_INV_SRC_ALPHA, // DstBlend
					D3D11_BLEND_OP_ADD, // BlendOp
					D3D11_BLEND_SRC_ALPHA, // SrcBlendAlpha,
					D3D11_BLEND_INV_SRC_ALPHA, // DestBlendAlpha
					D3D11_BLEND_OP_ADD, // BlendOpAlpha
					D3D11_COLOR_WRITE_ENABLE_ALL // RenderTargetWriteMask
				}
				, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
				, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
				, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
				, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
				, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
				, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
				, { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
			}
		};
		m_Device->CreateBlendState(&blendDesc, &m_BlendState);
	}

	// Digits Texture:
	{
		void * pImageData = malloc(sizeof(unsigned char*)*4*256*128);
		if(pImageData) {
			std::wstring fileName = GetHlaeFolderW();
			fileName += L"resources\\hexfont.tga";

			FILE* file;
			_wfopen_s(&file, fileName.c_str(), L"rb");
			if (file)
			{
				fseek(file, 18, SEEK_SET);

				fread(pImageData,sizeof(unsigned char),4*256*128,file);

				fclose(file);
			}

			D3D11_SUBRESOURCE_DATA subResourceData {
				pImageData,
				sizeof(unsigned char)*4*256,
				0
			};

			D3D11_TEXTURE2D_DESC textureDesc = {
				256, // width
				128, // height
				1, // MipLevels
				1, // ArraySize,
				DXGI_FORMAT_B8G8R8A8_UNORM, // Format
				{1,0}, // smaple count, sample quality
				D3D11_USAGE_IMMUTABLE, // Usage
				D3D11_BIND_SHADER_RESOURCE, // BindFlags,
				0, // CPUAccessFlags
				0 // MiscFlags
			};

			m_Device->CreateTexture2D(&textureDesc,&subResourceData,&m_DigitsTexture);

			free(pImageData);

			if(m_DigitsTexture) {
				D3D11_SHADER_RESOURCE_VIEW_DESC resourceViewDesc {
					DXGI_FORMAT_B8G8R8A8_UNORM,
					D3D11_SRV_DIMENSION_TEXTURE2D
				};
				resourceViewDesc.Texture2D.MostDetailedMip = 0;
				resourceViewDesc.Texture2D.MipLevels = 1;

				m_Device->CreateShaderResourceView(m_DigitsTexture,&resourceViewDesc,&m_DigitsTextureRV);
			}
		}		
	}
}

void CCampathDrawer::BuildPolyLinePoint(Vector3 previous, Vector3 current, DWORD currentColor, Vector3 next, Vertex * pOutVertexData)
{
	Vector3 toPrevious = (previous-current).Normalize();
	Vector3 toNext = (next-current).Normalize();
	double lengthPrevious = (previous-current).Length()/8192;
	double lengthNext = (next-current).Length()/8192;
	
	pOutVertexData[1].x = pOutVertexData[0].x = (float)current.X;
	pOutVertexData[1].y = pOutVertexData[0].y = (float)current.Y;
	pOutVertexData[1].z = pOutVertexData[0].z = (float)current.Z;

	pOutVertexData[3].t1u = pOutVertexData[2].t1u = pOutVertexData[1].t1u = pOutVertexData[0].t1u = (float)toPrevious.X;
	pOutVertexData[3].t1v = pOutVertexData[2].t1v = pOutVertexData[1].t1v = pOutVertexData[0].t1v = (float)toPrevious.Y;
	pOutVertexData[3].t1w = pOutVertexData[2].t1w = pOutVertexData[1].t1w = pOutVertexData[0].t1w = (float)toPrevious.Z;

	pOutVertexData[3].t2u = pOutVertexData[2].t2u = pOutVertexData[1].t2u = pOutVertexData[0].t2u = (float)toNext.X;
	pOutVertexData[3].t2v = pOutVertexData[2].t2v = pOutVertexData[1].t2v = pOutVertexData[0].t2v = (float)toNext.Y;
	pOutVertexData[3].t2w = pOutVertexData[2].t2w = pOutVertexData[1].t2w = pOutVertexData[0].t2w = (float)toNext.Z;

	pOutVertexData[0].t0u = 1.0f;
	pOutVertexData[1].t0u = -1.0f;

	pOutVertexData[1].t0v = pOutVertexData[0].t0v = (float)lengthPrevious;
	pOutVertexData[1].t0w = pOutVertexData[0].t0w = (float)lengthNext;

	pOutVertexData[1].diffuse = pOutVertexData[0].diffuse = currentColor;
}

void CCampathDrawer::CampathChangedFn(void * pUserData) {
		static_cast<CCampathDrawer*>(pUserData)->CamPathChanged();
}

void CCampathDrawer::CamPathChanged()
{
	if(m_LessDynamicProperties) {
		m_LessDynamicProperties->Release();
		m_LessDynamicProperties = nullptr;
	}
}

void CCampathDrawer::Draw_set(bool value)
{
	m_Draw = value;
}

bool CCampathDrawer::Draw_get(void)
{
	return m_Draw;
}

void CCampathDrawer::EndDevice()
{
	if(0 == m_Device)
		return;

	UnloadVertexBuffer();

	if(m_DigitsTextureRV) {
		m_DigitsTextureRV->Release();
		m_DigitsTextureRV = nullptr;
	}
	if (m_DigitsTexture)
	{
		m_DigitsTexture->Release();
		m_DigitsTexture = nullptr;
	}

	if(m_ConstantBufferWidth) {
		m_ConstantBufferWidth->Release();
		m_ConstantBufferWidth = nullptr;
	}

	if(m_ConstantBuffer) {
		m_ConstantBuffer->Release();
		m_ConstantBuffer = nullptr;
	}

	if(m_DepthStencilStateDigits) {
		m_DepthStencilStateDigits->Release();
		m_DepthStencilStateDigits = nullptr;
	}
	if(m_DepthStencilStateLines) {
		m_DepthStencilStateLines->Release();
		m_DepthStencilStateLines = nullptr;
	}
	if(m_SamplerState) {
		m_SamplerState->Release();
		m_SamplerState = nullptr;
	}
	if(m_RasterizerStateDigits) {
		m_RasterizerStateDigits->Release();
		m_RasterizerStateDigits = nullptr;
	}
	if(m_RasterizerStateLines) {
		m_RasterizerStateLines->Release();
		m_RasterizerStateLines = nullptr;
	}
	if(m_BlendState) {
		m_BlendState->Release();
		m_BlendState = nullptr;
	}

	if (m_DrawTextureShader) {
		m_DrawTextureShader->Release();
		m_DrawTextureShader = nullptr;
	}

	if(m_DrawTextureVertexShader) {
		m_DrawTextureVertexShader->Release();
		m_DrawTextureVertexShader = nullptr;
	}

	if(m_PixelShader) {
		m_PixelShader->Release();
		m_PixelShader = nullptr;
	}

	if(m_InputLayoutLines) {
		m_InputLayoutLines->Release();
		m_InputLayoutLines = nullptr;
	}

	if(m_InputLayoutDigits) {
		m_InputLayoutDigits->Release();
		m_InputLayoutDigits = nullptr;
	}

	if(m_VertexShader) {
		m_VertexShader->Release();
		m_VertexShader = nullptr;
	}

	if(m_DeviceContext) {
		m_DeviceContext->Release();
		m_DeviceContext = nullptr;
	}

	m_Device->Release();
	m_Device = 0;
}

void CCampathDrawer::Begin() {
	g_CamPath.OnChangedAdd(CCampathDrawer::CampathChangedFn,this);
	CamPathChanged();
}

void CCampathDrawer::End() {
	g_CamPath.OnChangedRemove(CCampathDrawer::CampathChangedFn,this);
}

#define ValToUCCondInv(value,invert) ((invert) ? 0xFF -(unsigned char)(value) : (unsigned char)(value) )

extern float curtime_get(void);
extern int g_iWidth;
extern int g_iHeight;
extern SOURCESDK::VMatrix g_WorldToScreenMatrix;

CCampathDrawer::CDynamicProperties::CDynamicProperties(CCampathDrawer * drawer) {
	m_CurTime = curtime_get() - g_CamPath.GetOffset();
	m_InCampath = 1 <= g_CamPath.GetSize()
		&&	g_CamPath.GetLowerBound() <= m_CurTime
		&& m_CurTime <= g_CamPath.GetUpperBound();
	m_CampathEnabled = g_CamPath.Enabled_get();

	m_ScreenWidth = g_iWidth;
	m_ScreenHeight = g_iHeight;
	m_WorldToScreenMatrix = g_WorldToScreenMatrix;

	// Provide view plane info for line clipping:
	double plane0[4] = { 0,0,0,1 };
	double planeN[4] = { 1,0,0,1 };
	double planeR[4] = { 0,-1,0,1 };
	double planeU[4] = { 0,0,1,1 };
	{

		unsigned char P[4];
		unsigned char Q[4];

		double L[4][4];
		double U[4][4];

		double M[4][4] = {
			m_WorldToScreenMatrix.m[0][0], m_WorldToScreenMatrix.m[0][1], m_WorldToScreenMatrix.m[0][2], 0,
			m_WorldToScreenMatrix.m[1][0], m_WorldToScreenMatrix.m[1][1], m_WorldToScreenMatrix.m[1][2], 0,
			m_WorldToScreenMatrix.m[2][0], m_WorldToScreenMatrix.m[2][1], m_WorldToScreenMatrix.m[2][2], 0,
			m_WorldToScreenMatrix.m[3][0], m_WorldToScreenMatrix.m[3][1], m_WorldToScreenMatrix.m[3][2], -1,
		};

		double b0[4] = {
			0 - m_WorldToScreenMatrix.m[0][3],
			0 - m_WorldToScreenMatrix.m[1][3],
			0 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};

		double bN[4] = {
			0 - m_WorldToScreenMatrix.m[0][3],
			0 - m_WorldToScreenMatrix.m[1][3],
			1 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};
		double bR[4] = {
			1 - m_WorldToScreenMatrix.m[0][3],
			0 - m_WorldToScreenMatrix.m[1][3],
			0 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};

		double bU[4] = {
			0 - m_WorldToScreenMatrix.m[0][3],
			1 - m_WorldToScreenMatrix.m[1][3],
			0 - m_WorldToScreenMatrix.m[2][3],
			-m_WorldToScreenMatrix.m[3][3],
		};
		if (!LUdecomposition(M, P, Q, L, U))
		{
			advancedfx::Warning("AFXERROR in CCampathDrawer::OnPostRenderAllTools: LUdecomposition failed\n");
		}
		else
		{
			SolveWithLU(L, U, P, Q, b0, plane0);
			SolveWithLU(L, U, P, Q, bN, planeN);

			SolveWithLU(L, U, P, Q, bR, planeR);
			SolveWithLU(L, U, P, Q, bU, planeU);
		}

		/*
		vvPos = Vector3(plane0[0], plane0[1], plane0[2]);
		vvForward = Vector3(planeN[0] -vvPos.X, planeN[1] -vvPos.Y, planeN[2]-vvPos.Z);
		vvForward.Normalize();
		vvRight = Vector3(planeR[0] -vvPos.X, planeR[1] -vvPos.Y, planeR[2]-vvPos.Z);
		vvRight.Normalize();
		vvUp = Vector3(planeU[0] -vvPos.X, planeU[1] -vvPos.Y, planeU[2]-vvPos.Z);
		vvUp.Normalize();
		*/

		/*
		advancedfx::Message("CCampathDrawer::OnPostRenderAllTools: curTime = %f\n",m_CurTime);
		advancedfx::Message("M[0]=%f %f %f %f\nM[1]=%f %f %f %f\nM[2]=%f %f %f %f\nM[3]=%f %f %f %f\n", M[0][0],M[0][1],M[0][2],M[0][3], M[1][0],M[1][1],M[1][2],M[1][3], M[2][0],M[2][1],M[2][2],M[2][3], M[3][0],M[3][1],M[3][2],M[3][3]);
		advancedfx::Message("b0[0]=%f %f %f %f\n", b0[0], b0[1], b0[2], b0[3]);
		advancedfx::Message("bN[0]=%f %f %f %f\n", bN[0], bN[1], bN[2], bN[3]);
		advancedfx::Message("plane0=%f %f %f %f\n", plane0[0], plane0[1], plane0[2], plane0[3]);
		advancedfx::Message("planeN=%f %f %f %f\n", planeN[0], planeN[1], planeN[2], planeN[3]);
		*/

		m_PlaneOrigin = Vector3(plane0[0],plane0[1],plane0[2]);
		
		m_PlaneNormal = Vector3(planeN[0] - plane0[0], planeN[1] - plane0[1], planeN[2] - plane0[2]); 
		m_PlaneNormal.Normalize();

		m_PlaneRight = Vector3(planeR[0] - plane0[0], planeR[1] - plane0[1], planeR[2] - plane0[2]);
		m_PlaneRight.Normalize();

		m_PlaneUp = Vector3(planeU[0] - plane0[0], planeU[1] - plane0[1], planeU[2] - plane0[2]);
		m_PlaneUp.Normalize();		
	}

	m_DrawKeyFrameIndex = drawer->m_DrawKeyframIndex;
	m_DrawKeyframeAxis = drawer->m_DrawKeyframeAxis;
	m_DrawKeyframeCam = drawer->m_DrawKeyframeCam;

	if(g_CamPath.CanEval() && 2 <= g_CamPath.GetSize()) {
		m_CurrentValue = g_CamPath.Eval(m_CurTime);
	}
}

CCampathDrawer::CLessDynamicProperties::CLessDynamicProperties(CCampathDrawer * drawer) {

	m_CampathCanEval = g_CamPath.CanEval();

	for (CamPathIterator it = g_CamPath.GetBegin(); it != g_CamPath.GetEnd(); ++it)
	{
		m_Keyframes.emplace_back(it.GetTime(), it.GetValue());
	}

	if(m_CampathCanEval && 2 <= m_Keyframes.size()) {
		// Build trajectory points.
		// This operation can be quite expensive (up to O(N^2)),
		// so it should be done only when s.th.
		// changed (which is what we do here).

		auto last = g_CamPath.GetBegin();
		auto it = last;

		TempPoint * pts = new TempPoint[c_CameraTrajectoryMaxPointsPerInterval];

		for(++it; it != g_CamPath.GetEnd(); ++it)
		{
			double delta = it.GetTime() - last.GetTime();

			for(size_t i = 0; i<c_CameraTrajectoryMaxPointsPerInterval; i++)
			{
				double t = last.GetTime() + delta*((double)i/(c_CameraTrajectoryMaxPointsPerInterval-1));

				CamPathValue cpv = g_CamPath.Eval(t);

				pts[i].t = t;
				pts[i].y = Vector3(cpv.X, cpv.Y, cpv.Z);
				pts[i].nextPt = i+1 <c_CameraTrajectoryMaxPointsPerInterval ? &(pts[i+1]) : 0;
			}

			RamerDouglasPeucker(&(pts[0]), &(pts[c_CameraTrajectoryMaxPointsPerInterval-1]), c_CameraTrajectoryEpsilon);

			// add all points except the last one (to avoid duplicates):
			for(TempPoint * pt = &(pts[0]); pt && pt->nextPt; pt = pt->nextPt)
			{
				m_TrajectoryPoints.emplace_back(
					pt->t,
					g_CamPath.Eval(pt->t));
			}

			last = it;
		}

		// add last point:
		m_TrajectoryPoints.emplace_back(
			pts[c_CameraTrajectoryMaxPointsPerInterval-1].t,
			g_CamPath.Eval(pts[c_CameraTrajectoryMaxPointsPerInterval-1].t));

		delete[] pts;
	}
}

void CCampathDrawer::CCampathDrawerFunctor::operator()() {
	g_CampathDrawer.OnPostRenderAllTools_DrawingThread(m_DynamicProperties, m_LessDynamicProperties);
}

void CCampathDrawer::OnEngineThread_SetupViewDone() {
	// Actually we are often called twice per frame , once after 3d skybox
	// and once after world is drawn, maybe we will be even called more times.

	if(!m_Draw)
		return;

	if(nullptr == m_LessDynamicProperties) {
		m_LessDynamicProperties = new CLessDynamicProperties(this); // CPU expensive.
		m_LessDynamicProperties->AddRef();		
	}

	{
		std::unique_lock<std::mutex> lock(m_FunctorMutex);
		if(!m_Functors.empty()) {
			auto it = m_Functors.rbegin();
			CMaterialSystemFunctor* pFunctor = *it;
			if(pFunctor) {
				delete pFunctor;
				std::advance(it, 1);
				m_Functors.erase(it.base());
			}
		}
		m_Functors.emplace_back(new CCampathDrawerFunctor(this));
	}
}

void CCampathDrawer::OnEngineThread_EndFrame() {
	std::unique_lock<std::mutex> lock(m_FunctorMutex);
	m_Functors.emplace_back(nullptr);
}

void CCampathDrawer::OnRenderThread_Draw(ID3D11DeviceContext * pImmediateContext, const D3D11_VIEWPORT * pViewPort, ID3D11RenderTargetView * pRenderTargetView2, ID3D11DepthStencilView * pDepthStencilView2) {
	CMaterialSystemFunctor* pFunctor = nullptr;		
	{
		std::unique_lock<std::mutex> lock(m_FunctorMutex);
		if(!m_Functors.empty()) {
			auto it = m_Functors.begin();
			pFunctor = *it;
			if(nullptr != pFunctor)
				m_Functors.erase(it);
		}
	}

	if(pFunctor) {
		m_ImmediateContext = pImmediateContext;
		m_Rtv2 = pRenderTargetView2;
		m_Dsv2 = pDepthStencilView2;
		m_pViewPort = pViewPort;
		pFunctor->operator()();
		m_pViewPort = nullptr;
		m_Dsv2 = nullptr;
		m_Rtv2 = nullptr;
		m_ImmediateContext = nullptr;
		delete pFunctor;
	}
}

void CCampathDrawer::OnRenderThread_Present() {
	CMaterialSystemFunctor* pFunctor = nullptr;		
	{
		std::unique_lock<std::mutex> lock(m_FunctorMutex);
		while(!m_Functors.empty()) {
			auto it = m_Functors.begin();
			pFunctor = *it;
			if(nullptr != pFunctor) {
				delete pFunctor;
				m_Functors.erase(it);
			} else {
				m_Functors.erase(it);
				if(m_Functors.size() <= 128) break;
			}
		}
	}	
}

void CCampathDrawer::SetLineWidth(float width) {
	VS_CONSTANT_BUFFER_WIDTH screenInfo = {
		{ width, 0, 0, 0 }
	};
	{
		D3D11_MAPPED_SUBRESOURCE mappedResource;
		if(SUCCEEDED(m_DeviceContext->Map(m_ConstantBufferWidth, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource))) {
			memcpy(mappedResource.pData, &screenInfo, sizeof(screenInfo));
			m_DeviceContext->Unmap(m_ConstantBufferWidth, 0);
		}
	}
	m_DeviceContext->VSSetConstantBuffers(1,1,&m_ConstantBufferWidth);
}

void CCampathDrawer::OnPostRenderAllTools_DrawingThread(CDynamicProperties * dynamicPorperties, CLessDynamicProperties * lessDynamicProperties)
{
	if(!(m_Device
		&& m_DeviceContext 
		&& m_VertexShader && m_PixelShader && m_DrawTextureShader && m_DrawTextureVertexShader
		&& m_ConstantBuffer
		&& m_ConstantBufferWidth
		&& m_DepthStencilStateDigits
		&& m_DepthStencilStateLines
		&& m_SamplerState
		&& m_RasterizerStateDigits
		&& m_RasterizerStateLines
		&& m_BlendState
		&& m_InputLayoutDigits
		&& m_InputLayoutLines
		&& m_ImmediateContext
		&& m_Rtv2
		&& m_pViewPort
		//&& m_Dsv2
		))
	{
		static bool firstError = true;

		if(firstError)
		{
			firstError = false;
			advancedfx::Warning(
				"AFXERROR: CCampathDrawer::OnEndScene: Missing required dependencies.\n"
			);
		}

		return;
	}

	//FLOAT clearColor[4]={0.0f, 0.0f, 0.5f, 1.0f};
	//m_DeviceContext->ClearRenderTargetView(m_Rtv,clearColor);
	m_DeviceContext->OMSetRenderTargets(1,&m_Rtv2,m_Dsv2);

	m_DeviceContext->PSSetSamplers(0,1,&m_SamplerState);
	m_DeviceContext->OMSetBlendState(m_BlendState,NULL, 0xffffffff);

	int screenWidth = dynamicPorperties->GetScreenWidth();
	int screenHeight = dynamicPorperties->GetScreenHeight();
/*
	D3D11_VIEWPORT viewPort = {
		0, // TopLeftX
		0, // TopLeftY
		(float)screenWidth,
		(float)screenHeight,
		0, // MinDepth
		1 // MaxDepth
	};
	UINT numViewports = 1;
	m_ImmediateContext->RSGetViewports(&numViewports,&viewPort);
*/
	m_DeviceContext->RSSetViewports(1,m_pViewPort);

	const SOURCESDK::VMatrix & worldToScreenMatrix = dynamicPorperties->GetWorldToScreenMatrix();
	const Vector3 & planeOrigin = dynamicPorperties->GetPlaneOrigin();
	const Vector3 & planeNormal = dynamicPorperties->GetPlaneNormal();


	VS_CONSTANT_BUFFER constant_buffer = {
		{
			worldToScreenMatrix.m[0][0], worldToScreenMatrix.m[0][1], worldToScreenMatrix.m[0][2], worldToScreenMatrix.m[0][3],
			worldToScreenMatrix.m[1][0], worldToScreenMatrix.m[1][1], worldToScreenMatrix.m[1][2], worldToScreenMatrix.m[1][3],
			worldToScreenMatrix.m[2][0], worldToScreenMatrix.m[2][1], worldToScreenMatrix.m[2][2], worldToScreenMatrix.m[2][3],
			worldToScreenMatrix.m[3][0], worldToScreenMatrix.m[3][1], worldToScreenMatrix.m[3][2], worldToScreenMatrix.m[3][3]
		},
		{ (float)planeOrigin.X, (float)planeOrigin.Y, (float)planeOrigin.Z, 0 },
		{ (float)planeNormal.X, (float)planeNormal.Y, (float)planeNormal.Z, 0 },
		{ 0 != screenWidth ? 1.0f / screenWidth : 0.0f, 0 != screenHeight ? 1.0f / screenHeight : 0.0f, 0, 0 }
	};
	{
		D3D11_MAPPED_SUBRESOURCE mappedResource;
		if(SUCCEEDED(m_DeviceContext->Map(m_ConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource))) {
			memcpy(mappedResource.pData, &constant_buffer, sizeof(constant_buffer));
			m_DeviceContext->Unmap(m_ConstantBuffer, 0);
		}
	}
	m_DeviceContext->VSSetConstantBuffers(0,1,&m_ConstantBuffer);

	// Draw:
	{
		//Vector3 vvForward, vvUp, vvRight, vvPos;

		double curTime = dynamicPorperties->GetCurTime();
		bool inCampath = dynamicPorperties->GetInCampath();
		bool campathCanEval = lessDynamicProperties->GetCampathCanEval();
		bool campathEnabled = dynamicPorperties->GetCampathEnabled();
		bool cameraMightBeSelected = false;

		// Draw keyframes index:
		float drawKeyFrameIndex = dynamicPorperties->GetDrawKeyframeIndex();
		if (drawKeyFrameIndex) {
			if (m_DigitsTextureRV)
			{
				m_DeviceContext->IASetInputLayout(m_InputLayoutDigits);

				m_DeviceContext->OMSetDepthStencilState(m_DepthStencilStateDigits, 0);
				m_DeviceContext->RSSetState(m_RasterizerStateDigits);

				//m_Device->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);

				m_DeviceContext->VSSetShader(m_DrawTextureVertexShader, NULL, 0);
				m_DeviceContext->PSSetShader(m_DrawTextureShader, NULL, 0);

				//m_Device->SetRenderState(D3DRS_ALPHAREF, (DWORD)0x00000001);
				//m_Device->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
				//m_Device->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL);

				//m_Device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
				//m_Device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
				//m_Device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
				//m_Device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
				//m_Device->SetSamplerState(0, D3DSAMP_SRGBTEXTURE, FALSE);

				// texture:
				m_DeviceContext->PSSetShaderResources(0,1,&m_DigitsTextureRV);

				int index = 0;

				const Vector3 & vvRight = dynamicPorperties->GetPlaneRight();
				const Vector3 & vvUp = dynamicPorperties->GetPlaneUp();

				for (auto it = lessDynamicProperties->GetKeyframesBegin(); it != lessDynamicProperties->GetKeyframesEnd(); it++)
				{
					int digits = 0;
					for (int t = index; 0 < t; t = t / 10)
					{
						++digits;
					}
					if (digits < 1) digits = 1;

					double cpT = it->GetTime();
					CamPathValue cpv = it->GetValue();

					int val = index;

					for (int i = 0; i < digits; ++i)
					{
						int cval = val % 10;
						val = val / 10;

						float left = -0.5f * drawKeyFrameIndex * (i + 1);
						float top = 0.5f * drawKeyFrameIndex;
						float bottom = -0.5f * drawKeyFrameIndex;
						float right = left + 0.5f * drawKeyFrameIndex;

						float tx = (32 * (cval % 8)) / 256.0f;
						float ty = (64 * (cval / 8)) / 128.0f;

						AutoSingleQuad(
							Vector3(cpv.X + left * vvRight.X + top * vvUp.X, cpv.Y + left * vvRight.Y + top * vvUp.Y, cpv.Z + left * vvRight.Z + top * vvUp.Z), tx, ty,
							Vector3(cpv.X + left * vvRight.X + bottom * vvUp.X, cpv.Y + left * vvRight.Y + bottom * vvUp.Y, cpv.Z + left * vvRight.Z + bottom * vvUp.Z), tx, ty + 64 / 128.0f,
							Vector3(cpv.X + right * vvRight.X + top * vvUp.X, cpv.Y + right * vvRight.Y + top * vvUp.Y, cpv.Z + right * vvRight.Z + top * vvUp.Z),  tx + 32 / 256.0f, ty,
							Vector3(cpv.X + right * vvRight.X + bottom * vvUp.X, cpv.Y + right * vvRight.Y + bottom * vvUp.Y, cpv.Z + right * vvRight.Z + bottom * vvUp.Z), tx + 32 / 256.0f, ty + 64 / 128.0f
						);
					}

					// cameraMightBeSelected = cameraMightBeSelected || lpSelected && cpv.Selected && lpTime <= curTime && curTime <= cpT;

					++index;
				}

				/*AutoSingleQuad(
					Vector3(-0.5, 0.5, 0), 0, 0,
					Vector3(-0.5,-0.5,0), 0, 1,
					Vector3(0.5,0.5,0),  1, 0,
					Vector3(0.5,-0.5,0), 1,  1
				);*/

				AutoSingleQuadFlush();
			}
		}

		m_DeviceContext->IASetInputLayout(m_InputLayoutLines);

		//m_Device->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);

		m_DeviceContext->OMSetDepthStencilState(m_DepthStencilStateLines, 0);
		m_DeviceContext->RSSetState(m_RasterizerStateLines);
					
		//m_Device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

		m_DeviceContext->VSSetShader(m_VertexShader,NULL,0);

		m_DeviceContext->PSSetShader(m_PixelShader, NULL, 0);

		// Draw trajectory:
		if(2 <= lessDynamicProperties->GetKeyframesSize() && lessDynamicProperties->GetCampathCanEval())
		{
			this->SetLineWidth(c_CameraTrajectoryPixelWidth);

			AutoPolyLineStart();

			auto itPts = lessDynamicProperties->GetTrajectoryPointsBegin();

			auto itKeysLast = lessDynamicProperties->GetKeyframesBegin();
			auto itKeysNext = itKeysLast;
			++itKeysNext;

			bool hasLastPt = false;
			bool hasNextPt = false;
			bool hasCurPt = false;
			
			double lastPtTime;
			CamPathValue lastPtValue;
			double curPtTime;
			CamPathValue curPtValue;
			double nextPtTime;
			CamPathValue nextPtValue;

			do
			{
				if(hasNextPt)
				{
					hasLastPt = true;
					lastPtTime = curPtTime;
					lastPtValue = curPtValue;

					hasCurPt = true;
					curPtTime = nextPtTime;
					curPtValue = nextPtValue;

					hasNextPt = false;
				}
				else
				{
					hasCurPt = true;
					curPtTime = itPts->GetTime();
					curPtValue = itPts->GetValue();
					++itPts;
				}

				while(itKeysNext->GetTime() < curPtTime)
				{
					itKeysLast = itKeysNext;
					++itKeysNext;
				}

				if(itPts != lessDynamicProperties->GetTrajectoryPointsEnd())
				{
					hasNextPt = true;
					nextPtTime = itPts->GetTime();
					nextPtValue = itPts->GetValue();
					++itPts;
				}
				else
				{
					// current point is last point.
					hasNextPt = false;
					nextPtValue = curPtValue;
				}

				if(!hasLastPt)
				{
					// current point is first point.
					lastPtValue = curPtValue;
				}

				// emit current point:
				{
					double deltaTime = abs(curTime -curPtTime);

					DWORD colour;

					// determine colour:
					if(deltaTime < 1.0)
					{
						double t = (deltaTime -0.0)/1.0;
						colour = D3DCOLOR_RGBA(
							ValToUCCondInv(255.0*t, curPtValue.Selected),
							ValToUCCondInv(255, curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							(unsigned char)(127*(1.0-t))+128
						);
					}
					else
					if(deltaTime < 2.0)
					{
						double t = (deltaTime -1.0)/1.0;
						colour = D3DCOLOR_RGBA(
							ValToUCCondInv(255, curPtValue.Selected),
							ValToUCCondInv(255.0*(1.0-t), curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							(unsigned char)(64*(1.0-t))+64
						);
					}
					else
					{
						colour = D3DCOLOR_RGBA(
							ValToUCCondInv(255, curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							ValToUCCondInv(0, curPtValue.Selected),
							64
						);
					}

					AutoPolyLinePoint(
						Vector3(lastPtValue.X,lastPtValue.Y,lastPtValue.Z)
						, Vector3(curPtValue.X,curPtValue.Y,curPtValue.Z)
						, colour
						, Vector3(nextPtValue.X,nextPtValue.Y,nextPtValue.Z));
				}
			}
			while(hasNextPt);

			AutoPolyLineFlush();
		}

		// Draw keyframes:
		{
			this->SetLineWidth(c_CampathCrossPixelWidth);

			bool lpSelected = false;
			double lpTime;
			
			for(auto it = lessDynamicProperties->GetKeyframesBegin(); it != lessDynamicProperties->GetKeyframesEnd(); it++)
			{
				double cpT = it->GetTime();
				CamPathValue cpv = it->GetValue();

				cameraMightBeSelected = cameraMightBeSelected || lpSelected && cpv.Selected && lpTime <= curTime && curTime <= cpT;

				lpSelected = cpv.Selected;
				lpTime = cpT;

				double deltaTime = abs(curTime -cpT);

				bool selected = cpv.Selected;

				DWORD colour;

				// determine colour:
				if(deltaTime < 1.0)
				{
					double t = (deltaTime -0.0)/1.0;
					colour = D3DCOLOR_RGBA(
						ValToUCCondInv(255.0*t, selected),
						ValToUCCondInv(255, selected),
						ValToUCCondInv(0, selected),
						(unsigned char)(127*(1.0-t))+128
					);
				}
				else
				if(deltaTime < 2.0)
				{
					double t = (deltaTime -1.0)/1.0;
					colour = D3DCOLOR_RGBA(
						ValToUCCondInv(255, selected),
						ValToUCCondInv(255.0*(1.0-t), selected),
						ValToUCCondInv(0, selected),
						(unsigned char)(64*(1.0-t))+64
					);
				}
				else
				{
					colour = D3DCOLOR_RGBA(
						ValToUCCondInv(255, selected),
						ValToUCCondInv(0, selected),
						ValToUCCondInv(0, selected),
						64
					);
				}

				if (dynamicPorperties->GetDrawKeyframeAxis())
				{
					// x / forward line:

					AutoSingleLine(
						Vector3(cpv.X - c_CampathCrossRadius, cpv.Y, cpv.Z),
						colour,
						Vector3(cpv.X + c_CampathCrossRadius, cpv.Y, cpv.Z),
						colour
					);

					// y / left line:

					AutoSingleLine(
						Vector3(cpv.X, cpv.Y - c_CampathCrossRadius, cpv.Z),
						colour,
						Vector3(cpv.X, cpv.Y + c_CampathCrossRadius, cpv.Z),
						colour
					);

					// z / up line:

					AutoSingleLine(
						Vector3(cpv.X, cpv.Y, cpv.Z - c_CampathCrossRadius),
						colour,
						Vector3(cpv.X, cpv.Y, cpv.Z + c_CampathCrossRadius),
						colour
					);
				}

				if(dynamicPorperties->GetDrawKeyframeCam()) DrawCamera(cpv, colour, dynamicPorperties->GetScreenWidth(), dynamicPorperties->GetScreenHeight());
			}

			AutoSingleLineFlush();
		}

		// Draw wireframe camera:
		if(dynamicPorperties->GetInCampath() && lessDynamicProperties->GetCampathCanEval())
		{
			DWORD colourCam = dynamicPorperties->GetCampathEnabled()
				? D3DCOLOR_RGBA(
					ValToUCCondInv(255,cameraMightBeSelected),
					ValToUCCondInv(0,cameraMightBeSelected),
					ValToUCCondInv(255,cameraMightBeSelected),
					128)
				: D3DCOLOR_RGBA(
					ValToUCCondInv(255,cameraMightBeSelected),
					ValToUCCondInv(255,cameraMightBeSelected),
					ValToUCCondInv(255,cameraMightBeSelected),
					128);

			CamPathValue cpv = dynamicPorperties->GetCurrentValue();

			this->SetLineWidth(c_CameraPixelWidth);

			DrawCamera(cpv, colourCam, dynamicPorperties->GetScreenWidth(), dynamicPorperties->GetScreenHeight());

			AutoSingleLineFlush();
		}
	}

	//
	ID3D11CommandList * pCommandList = nullptr;
	m_DeviceContext->FinishCommandList(FALSE, &pCommandList);
	if(pCommandList) {
		m_ImmediateContext->ExecuteCommandList(pCommandList,
			TRUE // RestoreContextState has quite some performance impact on TRUE, let's try FALSE first
		);
		pCommandList->Release();
	}
}

void CCampathDrawer::DrawCamera(const CamPathValue & cpv, DWORD colour, int screenWidth, int screenHeight)
{
	// limit to values as RenderView hook:
	double fov = min(179, max(1, cpv.Fov));

	double forward[3], right[3], up[3];
	QEulerAngles ang = cpv.R.ToQREulerAngles().ToQEulerAngles();
	MakeVectors(ang.Roll, ang.Pitch, ang.Yaw, forward, right, up);

	Vector3 vCp(cpv.X, cpv.Y, cpv.Z);
	Vector3 vForward(forward);
	Vector3 vUp(up);
	Vector3 vRight(right);

	double a = sin(fov * M_PI / 360.0) * c_CameraRadius;
	double b = a;

	double aspectRatio = screenWidth ? (double)screenHeight / (double)screenWidth : 1.0;

	b *= aspectRatio;

	Vector3 vLU = vCp + (double)c_CameraRadius * vForward - a * vRight + b * vUp;
	Vector3 vRU = vCp + (double)c_CameraRadius * vForward + a * vRight + b * vUp;
	Vector3 vLD = vCp + (double)c_CameraRadius * vForward - a * vRight - b * vUp;
	Vector3 vRD = vCp + (double)c_CameraRadius * vForward + a * vRight - b * vUp;
	Vector3 vMU = vLU + (vRU - vLU) / 2;
	Vector3 vMUU = vMU + 0.5 * b * vUp;

	AutoSingleLine(vCp, colour, vLD, colour);

	AutoSingleLine(vCp, colour, vRD, colour);

	AutoSingleLine(vCp, colour, vLU, colour);

	AutoSingleLine(vCp, colour, vRU, colour);

	AutoSingleLine(vLD, colour, vRD, colour);

	AutoSingleLine(vRD, colour, vRU, colour);

	AutoSingleLine(vRU, colour, vLU, colour);

	AutoSingleLine(vLU, colour, vLD, colour);

	AutoSingleLine(vLU, colour, vMUU, colour);

	AutoSingleLine(vRU, colour, vMUU, colour);
}

void CCampathDrawer::BuildSingleLine(Vector3 from, Vector3 to, Vertex * pOutVertexData)
{
	Vector3 normal = (to-from).Normalize();
	double length = (to-from).Length() / 8192;
	
	pOutVertexData[1].x = pOutVertexData[0].x = (float)from.X;
	pOutVertexData[3].x = pOutVertexData[2].x = (float)to.X;
	pOutVertexData[1].y = pOutVertexData[0].y = (float)from.Y;
	pOutVertexData[3].y = pOutVertexData[2].y = (float)to.Y;
	pOutVertexData[1].z = pOutVertexData[0].z = (float)from.Z;
	pOutVertexData[3].z = pOutVertexData[2].z = (float)to.Z;

	pOutVertexData[3].t1u = pOutVertexData[2].t1u = pOutVertexData[1].t1u = pOutVertexData[0].t1u = (float)-normal.X;
	pOutVertexData[3].t1v = pOutVertexData[2].t1v = pOutVertexData[1].t1v = pOutVertexData[0].t1v = (float)-normal.Y;
	pOutVertexData[3].t1w = pOutVertexData[2].t1w = pOutVertexData[1].t1w = pOutVertexData[0].t1w = (float)-normal.Z;

	pOutVertexData[3].t2u = pOutVertexData[2].t2u = pOutVertexData[1].t2u = pOutVertexData[0].t2u = (float)normal.X;
	pOutVertexData[3].t2v = pOutVertexData[2].t2v = pOutVertexData[1].t2v = pOutVertexData[0].t2v = (float)normal.Y;
	pOutVertexData[3].t2w = pOutVertexData[2].t2w = pOutVertexData[1].t2w = pOutVertexData[0].t2w = (float)normal.Z;

	pOutVertexData[2].t0u = pOutVertexData[0].t0u = 1.0f;
	pOutVertexData[3].t0u = pOutVertexData[1].t0u = -1.0f;

	pOutVertexData[1].t0v = pOutVertexData[0].t0v = 0.0f;
	pOutVertexData[1].t0w = pOutVertexData[0].t0w = (float)length;
	pOutVertexData[3].t0v = pOutVertexData[2].t0v = (float)length;
	pOutVertexData[3].t0w = pOutVertexData[2].t0w = 0.0f;
}

void CCampathDrawer::BuildSingleQuad(Vector3 p0, float t0x, float t0y, Vector3 p1, float t1x, float t1y, Vector3 p2, float t2x, float t2y, Vector3 p3, float t3x, float t3y, Vertex * pOutVertexData) {
	pOutVertexData[0].x = (float)p0.X;
	pOutVertexData[0].y = (float)p0.Y;
	pOutVertexData[0].z = (float)p0.Z;
	pOutVertexData[0].t0u = t0x;
	pOutVertexData[0].t0v = t0y;
	pOutVertexData[0].t0w = 0;
	pOutVertexData[0].t1u = 0;
	pOutVertexData[0].t1v = 0;
	pOutVertexData[0].t1w = 0;
	pOutVertexData[0].t2u = 0;
	pOutVertexData[0].t2v = 0;
	pOutVertexData[0].t2w = 0;
	pOutVertexData[1].x = (float)p1.X;
	pOutVertexData[1].y = (float)p1.Y;
	pOutVertexData[1].z = (float)p1.Z;
	pOutVertexData[1].t0u = t1x;
	pOutVertexData[1].t0v = t1y;
	pOutVertexData[1].t0w = 0;
	pOutVertexData[1].t1u = 0;
	pOutVertexData[1].t1v = 0;
	pOutVertexData[1].t1w = 0;
	pOutVertexData[1].t2u = 0;
	pOutVertexData[1].t2v = 0;
	pOutVertexData[1].t2w = 0;
	pOutVertexData[2].x = (float)p2.X;
	pOutVertexData[2].y = (float)p2.Y;
	pOutVertexData[2].z = (float)p2.Z;
	pOutVertexData[2].t0u = t2x;
	pOutVertexData[2].t0v = t2y;
	pOutVertexData[2].t0w = 0;
	pOutVertexData[2].t1u = 0;
	pOutVertexData[2].t1v = 0;
	pOutVertexData[2].t1w = 0;
	pOutVertexData[2].t2u = 0;
	pOutVertexData[2].t2v = 0;
	pOutVertexData[2].t2w = 0;
	pOutVertexData[3].x = (float)p3.X;
	pOutVertexData[3].y = (float)p3.Y;
	pOutVertexData[3].z = (float)p3.Z;
	pOutVertexData[3].t0u = t3x;
	pOutVertexData[3].t0v = t3y;
	pOutVertexData[3].t0w = 0;
	pOutVertexData[3].t1u = 0;
	pOutVertexData[3].t1v = 0;
	pOutVertexData[3].t1w = 0;
	pOutVertexData[3].t2u = 0;
	pOutVertexData[3].t2v = 0;
	pOutVertexData[3].t2w = 0;
}

void CCampathDrawer::BuildSingleLine(DWORD colorFrom, DWORD colorTo, Vertex * pOutVertexData)
{
	pOutVertexData[1].diffuse = pOutVertexData[0].diffuse = colorFrom;
	pOutVertexData[3].diffuse = pOutVertexData[2].diffuse = colorTo;
}

bool CCampathDrawer::LockVertexBuffer()
{
	if(m_VertexBuffer)
	{
		D3D11_MAPPED_SUBRESOURCE mappedResource;
		if(!SUCCEEDED(m_DeviceContext->Map(m_VertexBuffer,0,D3D11_MAP_WRITE_DISCARD,0,&mappedResource))) {
			m_LockedVertexBuffer = nullptr;
			return false;
		}
		m_LockedVertexBuffer = (CCampathDrawer::Vertex *)mappedResource.pData;
		return true;
	}

	UnlockVertexBuffer();

	D3D11_BUFFER_DESC cbDesc;
	cbDesc.ByteWidth = c_VertexBufferVertexCount * sizeof( Vertex );
	cbDesc.Usage = D3D11_USAGE_DYNAMIC;
	cbDesc.BindFlags =  D3D11_BIND_VERTEX_BUFFER;
	cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	cbDesc.MiscFlags = 0;
	cbDesc.StructureByteStride = 0;

	if(!SUCCEEDED(m_Device->CreateBuffer(
		&cbDesc, NULL, &m_VertexBuffer
	))) {
		if(m_VertexBuffer) m_VertexBuffer->Release();
		m_VertexBuffer = nullptr;
		return false;	
	}

	if(m_VertexBuffer)
	{
		D3D11_MAPPED_SUBRESOURCE mappedResource;
		if(!SUCCEEDED(m_DeviceContext->Map(m_VertexBuffer,0,D3D11_MAP_WRITE_DISCARD,0,&mappedResource))) {
			m_LockedVertexBuffer = nullptr;
			return false;
		}
		m_LockedVertexBuffer = (CCampathDrawer::Vertex *)mappedResource.pData;
		return true;
	}	

	return false;
}

void CCampathDrawer::UnlockVertexBuffer()
{
	if(m_VertexBuffer && m_LockedVertexBuffer)
	{
		m_DeviceContext->Unmap(m_VertexBuffer, 0);
		m_LockedVertexBuffer = nullptr;
	}
}

void CCampathDrawer::UnloadVertexBuffer()
{
	if(m_VertexBuffer) { m_VertexBuffer->Release(); m_VertexBuffer = nullptr; }
}

void CCampathDrawer::RamerDouglasPeucker(TempPoint * start, TempPoint * end, double epsilon)
{
	double dmax = 0;
	TempPoint * index = start;

	for(TempPoint * i = start->nextPt; i && i != end; i = i->nextPt)
	{
		double d = ShortestDistanceToSegment(i, start, end);
		if(d > dmax)
		{
			index = i;
			dmax = d;
		}
	}

	// If max distance is greater than epsilon, recursively simplify
	if ( dmax > epsilon )
	{
		RamerDouglasPeucker(start, index, epsilon);
		RamerDouglasPeucker(index, end, epsilon);
	} else {
		start->nextPt = end;
	}
}

void CCampathDrawer::Reset()
{
	UnloadVertexBuffer();
	if(m_DigitsTextureRV) {
		m_DigitsTextureRV->Release();
		m_DigitsTextureRV = nullptr;
	}
	if (m_DigitsTexture)
	{
		m_DigitsTexture->Release();
		m_DigitsTexture = nullptr;
	}
}

double CCampathDrawer::ShortestDistanceToSegment(TempPoint * pt, TempPoint * start, TempPoint * end)
{
	double ESx = end->y.X - start->y.X;
	double ESy = end->y.Y - start->y.Y;
	double ESz = end->y.Z - start->y.Z;
	double dESdES = ESx*ESx + ESy*ESy + ESz*ESz;
	double t = dESdES ? (
		(pt->y.X-start->y.X)*ESx +(pt->y.Y -start->y.Y)*ESy + (pt->y.Z -start->y.Z)*ESz
	) / dESdES : 0.0;

	if(t <= 0.0)
		return (start->y -pt->y).Length();
	else
	if(1.0 <= t)
		return (pt->y -end->y).Length();

	return (pt->y -(start->y +t*(end->y -start->y))).Length();
}
