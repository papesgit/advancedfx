#include "stdafx.h"

#include "RenderSystemDX11Hooks.h"

#include "CampathDrawer.h"
#include "ReShadeAdvancedfx.h"
#include "WrpConsole.h"
#include "CamIO.h"
#include "MirvFix.h"

#include "../shared/AfxDetours.h"
#include "../shared/binutils.h"
#include "../shared/Captures.h"
#include "../shared/FileTools.h"
#include "../shared/ImageBufferPoolThreadSafe.h"
#include "../shared/ImageTransformer.h"
#include "../shared/RecordingSettings.h"
#include "../shared/RefCountedThreadSafe.h"
#include "../shared/StringTools.h"
#include "../shared/CamIO.h"
#include "../shared/ConsolePrinter.h"

#include "../deps/release/prop/cs2/sdk_src/public/cdll_int.h"
#include "../deps/release/prop/cs2/sdk_src/public/icvar.h"

#include "../shaders/build/afx_depth_vs_5_0.h" // autogenerated
#include "../shaders/build/afx_depth_ps_5_0.h" // autogenerated

#include <d3d11.h>
#define _XM_NO_INTRINSICS_
#include <DirectXMath.h>

#include <set>
#include <map>
#include <queue>
#include <list>
#include <mutex>
#include <shared_mutex>
#include <condition_variable>
#include <atomic>
#include <thread>
#include <functional>

#include <dxgi.h>
#include <dxgi1_4.h>

extern advancedfx::CThreadPool * g_pThreadPool;
extern advancedfx::CImageBufferPoolThreadSafe * g_pImageBufferPoolThreadSafe;

extern SOURCESDK::CS2::ISource2EngineToClient * g_pEngineToClient;
extern SOURCESDK::CS2::ICvar * SOURCESDK::CS2::g_pCVar;

std::mutex g_SwapChainMutex;
std::queue<std::function<bool(ID3D11DeviceContext * pDeviceContext, ID3D11Texture2D * pTexture)>> g_SwapchainBeforePresentQueue;
std::queue<std::function<bool(ID3D11DeviceContext * pDeviceContext)>> g_SwapchainAfterPresentQueue;

bool g_bEnableReShade = true;

class CAfxCpuTexture
: public advancedfx::CRefCountedThreadSafe
, public advancedfx::ICapture
, public advancedfx::IImageBuffer
{
public:
    virtual void AddRef() override {
        advancedfx::CRefCountedThreadSafe::AddRef();
    }

    virtual void Release() override {
        advancedfx::CRefCountedThreadSafe::Release();
    }

    virtual const advancedfx::CImageFormat * GetImageBufferFormat() const {
        return &m_ImageFormat;
    }

    virtual const void * GetImageBufferData() const {
        return m_MappedResource.pData;
    }

	virtual const IImageBuffer* GetBuffer() const {
        return this;
    }

    CAfxCpuTexture(ID3D11Device * pDevice)
    : m_pDevice(pDevice)
    {
        m_pDevice->AddRef();
        m_MappedResource.pData = nullptr;
        m_Condition.notify_one();
    }

    void GpuCopyResource(ID3D11DeviceContext * pContext, ID3D11Texture2D * pTexture) {
        if(m_pCpuTexture == nullptr && pTexture) {
            D3D11_TEXTURE2D_DESC desc;
            pTexture->GetDesc(&desc);
            bool bMultiSampled = 1 < desc.SampleDesc.Count;
            desc.BindFlags = 0;
            desc.MiscFlags = 0;
            desc.MipLevels = 1;
            desc.SampleDesc.Count = 1;
            desc.SampleDesc.Quality = 0;
            advancedfx::ImageFormat format = advancedfx::ImageFormat::Unkown;
            switch(desc.Format) {
            case DXGI_FORMAT_R8G8B8A8_TYPELESS:
            case DXGI_FORMAT_R8G8B8A8_UNORM:
            case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
            case DXGI_FORMAT_R8G8B8A8_UINT:
            case DXGI_FORMAT_R8G8B8A8_SNORM:
            case DXGI_FORMAT_R8G8B8A8_SINT:
               format = advancedfx::ImageFormat::RGBA;
               desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
               break;
            default:
                advancedfx::Warning("AFXERROR: GpuCopyResource - unspported DXGI_FORMAT: %i\n",desc.Format);
            }
            if(bMultiSampled) {
                desc.Usage = D3D11_USAGE_DEFAULT;
                desc.CPUAccessFlags = 0;
                m_pDevice->CreateTexture2D(&desc, nullptr, &m_pResolveTexture);
            }
            desc.Usage = D3D11_USAGE_STAGING;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
            m_ImageFormat = advancedfx::CImageFormat(format, desc.Width, desc.Height);
            m_Format = desc.Format;
            m_pDevice->CreateTexture2D(&desc, nullptr, &m_pCpuTexture);
        }

        if(m_pCpuTexture && pTexture) {
            if(m_pResolveTexture) {
                pContext->ResolveSubresource(m_pResolveTexture, 0, pTexture, 0, m_Format);
                pContext->CopyResource(m_pCpuTexture, m_pResolveTexture);
            } else {
                pContext->CopyResource(m_pCpuTexture, pTexture);
            }
        }
    }

    void CpuSignalDone() {
        std::unique_lock<std::mutex> lock(m_Mutex);
        m_bCpuDone = true;
        m_Condition.notify_one();
    }     

    class advancedfx::IImageBuffer * CpuBeginAccess(ID3D11DeviceContext * pContext) {
        m_MappedResource.pData = nullptr;
        if(m_pCpuTexture) {
            if(SUCCEEDED(pContext->Map(m_pCpuTexture, 0, D3D11_MAP_READ , 0, &m_MappedResource))) {
                m_ImageFormat = advancedfx::CImageFormat(m_ImageFormat.Format, m_ImageFormat.Width, m_ImageFormat.Height, m_MappedResource.RowPitch);
                return this;
            }
        }
        return nullptr;
    }

    void IfAcccessedWaitForCpuAndEndAccess(ID3D11DeviceContext * pContext) {        
        if(m_MappedResource.pData) {
            WaitForCpu();
            pContext->Unmap(m_pCpuTexture, 0);    
            m_MappedResource.pData = nullptr;        
        }
    }

protected:
    virtual ~CAfxCpuTexture() {
        if(m_pCpuTexture) {
            m_pCpuTexture->Release();
        }
        if(m_pResolveTexture){
            m_pResolveTexture->Release();
        }
        m_pDevice->Release();
    }

private:
    ID3D11Device * m_pDevice;
    ID3D11Texture2D * m_pCpuTexture = nullptr;
    ID3D11Texture2D * m_pResolveTexture = nullptr;
    DXGI_FORMAT m_Format = DXGI_FORMAT_UNKNOWN;
    std::mutex m_Mutex;
    std::condition_variable m_Condition;
    bool m_bCpuDone = false;
    advancedfx::CImageFormat m_ImageFormat;
    D3D11_MAPPED_SUBRESOURCE m_MappedResource;


    void WaitForCpu() {
        std::unique_lock<std::mutex> lock(m_Mutex);
        m_Condition.wait(lock, [this] { return m_bCpuDone; });
        m_bCpuDone = false;
    }
};

class CAfxCapture {
public:
    CAfxCapture(class advancedfx::COutVideoStreamCreator* pOutVideoStreamCreator)
     : m_pOutVideoStreamCreator(pOutVideoStreamCreator)
    {
        m_pOutVideoStreamCreator->AddRef();
        m_ProcessingThread = std::thread(&CAfxCapture::ProcessingThreadFunc, this);
    }

    void Finish(ID3D11DeviceContext * pDeviceContext) {
        while(m_CpuTextures[0] || m_CpuTextures[1]) {
            if(m_CpuTextures[m_Index]) {
                m_CpuTextures[m_Index]->IfAcccessedWaitForCpuAndEndAccess(pDeviceContext);
                m_CpuTextures[m_Index]->Release();
                m_CpuTextures[m_Index] = nullptr;
            }
            m_Index = (m_Index + 1) % 2;
        }
    }

    ~CAfxCapture() {
        if(m_CpuTextures[0]) {
            m_CpuTextures[0]->Release();
        }
        if(m_CpuTextures[1]) {
            m_CpuTextures[1]->Release();
        }
        {
            std::unique_lock<std::mutex> lock(m_ProcessingThreadMutex);
            m_ShutDown = true;
            m_ProcessingThreadCv.notify_one();
        }
        m_ProcessingThread.join();
    }

    void OnBeforeGpuPresent(ID3D11DeviceContext * pDeviceContext, ID3D11Texture2D * pTexture) {
        if(m_CpuTextures[m_Index] == nullptr) {
            ID3D11Device * pDevice = nullptr;
            pDeviceContext->GetDevice(&pDevice);
            if(pDevice) {
                auto pCpuTexture = new CAfxCpuTexture(pDevice);
                pCpuTexture->AddRef();
                m_CpuTextures[m_Index] = pCpuTexture;
                pDevice->Release();
            }
        } else {
            m_CpuTextures[m_Index]->IfAcccessedWaitForCpuAndEndAccess(pDeviceContext);
        }
        m_CpuTextures[m_Index]->GpuCopyResource(pDeviceContext, pTexture);
    }

    void OnAfterGpuPresent(ID3D11DeviceContext * pDeviceContext) {
        m_Index = (m_Index + 1) % 2;
        if(m_CpuTextures[m_Index]) {
            m_CpuTextures[m_Index]->CpuBeginAccess(pDeviceContext);
            StartProcess(0,m_CpuTextures[m_Index]);
        }
    }

private:

    void StartProcess(size_t index, CAfxCpuTexture * pCpuTexture) {
        std::unique_lock<std::mutex> lock(m_ProcessingThreadMutex);
        if(index == 0) {
            m_In.push_back(new CBuffers(m_Streams_size));
        }
        (*m_In.rbegin())->SetAt(index, pCpuTexture);
        if (index + 1  >= m_Streams_size) {
            m_ProcessingThreadCv.notify_one();
        }
    }

    size_t m_Index = 0;
    CAfxCpuTexture * m_CpuTextures[2]={nullptr,nullptr};

    const size_t m_Streams_size = 1;
    class advancedfx::COutVideoStreamCreator* m_pOutVideoStreamCreator;
	advancedfx::COutVideoStream* m_OutVideoStream = nullptr;

	class CBuffers {
	public:
		CBuffers(size_t size) : m_Buffers(size) {
		}

		size_t GetSize() const {
			return m_Buffers.size();
		}

		class CAfxCpuTexture * GetAt(size_t index) const {
			return m_Buffers[index];
		}

		void SetAt(size_t index, class CAfxCpuTexture * value) {
			m_Buffers[index] = value;
		}

	private:
		std::vector<class CAfxCpuTexture *> m_Buffers;
	};

	std::mutex m_ProcessingThreadMutex;
	std::condition_variable m_ProcessingThreadCv;
	std::thread m_ProcessingThread;
	bool m_ShutDown = false;

	std::list<class CBuffers*> m_In;

	void ProcessingThreadFunc() {
		std::unique_lock<std::mutex> lock(m_ProcessingThreadMutex);
		while (!m_ShutDown || !m_In.empty()) {
			if (!m_In.empty()) {
				class CBuffers* buffers = m_In.front();
				if(buffers->GetSize() >= m_Streams_size) {
					class CBuffers* task = buffers;
					m_In.pop_front();
					lock.unlock();

                    size_t taskSize = task->GetSize();
                    for(size_t i=0; i < taskSize; i++) {
                        auto pTexture = task->GetAt(i);
                        if(pTexture) {
                            advancedfx::ICapture* noAlphaCapture = advancedfx::ImageTransformer::RgbaToBgr(g_pThreadPool,g_pImageBufferPoolThreadSafe,pTexture);
                            if (noAlphaCapture) {
                                if (const advancedfx::IImageBuffer* buffer = noAlphaCapture->GetBuffer()) {                            
                                    if (m_OutVideoStream == nullptr) {
                                        m_OutVideoStream = m_pOutVideoStreamCreator->CreateOutVideoStream(*buffer->GetImageBufferFormat());
                                        if (nullptr == m_OutVideoStream)
                                        {
                                            advancedfx::Warning("AFXERROR: Failed to create image stream for screen recording.\n");
                                        }
                                        else
                                        {
                                            m_OutVideoStream->AddRef();
                                        }
                                    }
                                    if (nullptr != m_OutVideoStream && !m_OutVideoStream->SupplyImageBuffer(buffer))
                                    {
                                        advancedfx::Warning("AFXERROR: Failed writing image for screen recording.\n");
                                    }
                                }
                                else {
                                   advancedfx::Warning("AFXERROR: Could not get capture buffer for screen recording.\n");
                                }
                                noAlphaCapture->Release();
                                noAlphaCapture = nullptr; 
                            }                               
                            pTexture->CpuSignalDone();
                        }
                    }

					delete task;
					task = nullptr;
					lock.lock();
				} else {
					m_ProcessingThreadCv.wait(lock);
				}
			} else {
				m_ProcessingThreadCv.wait(lock);
			}		
        }
        if(m_OutVideoStream) m_OutVideoStream->Release();
        m_pOutVideoStreamCreator->Release();
	}
};

D3D11_VIEWPORT g_ViewPort;

class CRenderSystemDrawingData {
public:
    CRenderSystemDrawingData() {
        m_Queue.emplace(CData());
    }

    void Push() {
        std::unique_lock<std::shared_timed_mutex> lock(m_Mutex);
        m_Queue.emplace(CData());
    }

    void Pop() {
        std::unique_lock<std::shared_timed_mutex> lock(m_Mutex);
        if(!m_Queue.empty()) m_Queue.pop();
    }

    void GetProjectionMatrix(SOURCESDK::VMatrix & projectionMatrix) {
        std::shared_lock<std::shared_timed_mutex> lock(m_Mutex);
        memcpy(projectionMatrix.m, m_Queue.front().m_ProjectionMatrix.m, sizeof(projectionMatrix.m));
    }

    void SetProjectionMatrix(const SOURCESDK::VMatrix & projectionMatrix) {
        std::unique_lock<std::shared_timed_mutex> lock(m_Mutex);
        memcpy(m_Queue.back().m_ProjectionMatrix.m, projectionMatrix.m, sizeof(projectionMatrix.m));
    }

private:
    struct CData {
        SOURCESDK::VMatrix m_ProjectionMatrix;

        CData() {
            m_ProjectionMatrix.m[0][0] = 1; m_ProjectionMatrix.m[0][1] = 0; m_ProjectionMatrix.m[0][2] = 0; m_ProjectionMatrix.m[0][3] = 0;
            m_ProjectionMatrix.m[1][0] = 0; m_ProjectionMatrix.m[1][1] = 1; m_ProjectionMatrix.m[1][2] = 0; m_ProjectionMatrix.m[1][3] = 0;
            m_ProjectionMatrix.m[2][0] = 0; m_ProjectionMatrix.m[2][1] = 0; m_ProjectionMatrix.m[2][2] = 1; m_ProjectionMatrix.m[2][3] = 0;
            m_ProjectionMatrix.m[3][0] = 0; m_ProjectionMatrix.m[3][1] = 0; m_ProjectionMatrix.m[3][2] = 0; m_ProjectionMatrix.m[3][3] = 1;
        }
    };

    std::shared_timed_mutex m_Mutex;
    std::queue<CData> m_Queue;

} g_RenderSystemDrawingData;



class CDepthCompositor {
public:
    void OnTargetBegin(ID3D11Device * pDevice, ID3D11Texture2D * pTexture) {
        if(pDevice && pTexture) {
            pDevice->AddRef();    
            m_pDevice = pDevice;
            pTexture->GetDesc(&m_DeviceTextureDesc);
            m_HasSmokeDepth = false;
            m_HasNormalDepth = false;

            {
                D3D11_TEXTURE2D_DESC depthTextureDesc;
                depthTextureDesc.Width = m_DeviceTextureDesc.Width;
                depthTextureDesc.Height = m_DeviceTextureDesc.Height;
                depthTextureDesc.MipLevels = 1;
                depthTextureDesc.ArraySize = 1;
                depthTextureDesc.Format = DXGI_FORMAT_R32_FLOAT;
                depthTextureDesc.SampleDesc.Count = 1;
                depthTextureDesc.SampleDesc.Quality = 0;
                depthTextureDesc.Usage = D3D11_USAGE_DEFAULT;
                depthTextureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
                depthTextureDesc.CPUAccessFlags = 0;
                depthTextureDesc.MiscFlags = 0;
                m_pDevice->CreateTexture2D(&depthTextureDesc, nullptr, &m_pDepthTexture);

                D3D11_RENDER_TARGET_VIEW_DESC rtvbuffer_desc = {};
                rtvbuffer_desc.Format = DXGI_FORMAT_R32_FLOAT;
                rtvbuffer_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
                rtvbuffer_desc.Texture2D.MipSlice = 0;
                if (m_pDepthTexture) {
                    m_pDevice->CreateRenderTargetView(m_pDepthTexture, &rtvbuffer_desc, &m_pDepthTextureRtv);
                }
            }

            m_pDevice->CreateDeferredContext(0, &m_DeviceContext);

            {
                D3D11_DEPTH_STENCIL_DESC depthStencilDesc{
                    FALSE, // DepthEnable;
                    D3D11_DEPTH_WRITE_MASK_ZERO, // DepthWriteMask
                    D3D11_COMPARISON_ALWAYS, // DepthFunc
                    FALSE, // StencilEnable
                    D3D11_DEFAULT_STENCIL_WRITE_MASK, // StencilReadMask
                    D3D11_DEFAULT_STENCIL_READ_MASK, // StencilWriteMask
                    { D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // FrontFace
                    { D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_STENCIL_OP_KEEP, D3D11_COMPARISON_ALWAYS }, // BackFace
                };
                m_pDevice->CreateDepthStencilState(&depthStencilDesc, &m_DepthStencilState);
            }

            {
                D3D11_RASTERIZER_DESC rasterizerDesc{
                    D3D11_FILL_SOLID, // FillMode
                    D3D11_CULL_NONE, // CullMode
                    TRUE, // FrontCounterClockwise
                    0, // DepthBias
                    0, // DepthBiasClamp
                    0, // SlopeScaledDepthBias
                    FALSE, // DepthClipEnable
                    FALSE, // ScissorEnable
                    TRUE, // MultisampleEnable
                    FALSE // AntialiasedLineEnable	
                };

                m_pDevice->CreateRasterizerState(&rasterizerDesc, &m_RasterizerState);
            }

            {
                D3D11_BLEND_DESC blendDesc{
                    FALSE, // AlphaToCoverageEnable
                    FALSE, // IndependentBlendEnable
                    // D3D11_RENDER_TARGET_BLEND_DESC
                    {
                        {
                            FALSE, // BlendEnable
                            D3D11_BLEND_SRC_ALPHA, // SrcBlend,
                            D3D11_BLEND_INV_SRC_ALPHA, // DstBlend
                            D3D11_BLEND_OP_ADD, // BlendOp
                            D3D11_BLEND_SRC_ALPHA, // SrcBlendAlpha,
                            D3D11_BLEND_INV_SRC_ALPHA, // DestBlendAlpha
                            D3D11_BLEND_OP_ADD, // BlendOpAlpha
                            D3D11_COLOR_WRITE_ENABLE_ALL // RenderTargetWriteMask
                        }
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                        , { FALSE, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL}
                    }
                };
                m_pDevice->CreateBlendState(&blendDesc, &m_BlendState);
            }

            {
                D3D11_BUFFER_DESC cbDesc;
                cbDesc.ByteWidth = sizeof(CS_CONSTANT_BUFFER);
                cbDesc.Usage = D3D11_USAGE_DYNAMIC;
                cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
                cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
                cbDesc.MiscFlags = 0;
                cbDesc.StructureByteStride = 0;

                m_pDevice->CreateBuffer(
                    &cbDesc, NULL, &m_ConstantBuffer
                );
            }

            if(Vertex* pVertexData = (Vertex*)malloc(sizeof(Vertex) * 4))
            {
                pVertexData[0].x = -1; pVertexData[0].y = 1;
                pVertexData[1].x = 1; pVertexData[1].y = 1;
                pVertexData[2].x = -1; pVertexData[2].y = -1;
                pVertexData[3].x = 1; pVertexData[3].y = -1;

                D3D11_SUBRESOURCE_DATA subResourceData{
                    pVertexData,
                    sizeof(Vertex) * 4,
                    0
                };

                D3D11_BUFFER_DESC cbDesc;
                cbDesc.ByteWidth = 4 * sizeof(Vertex);
                cbDesc.Usage = D3D11_USAGE_IMMUTABLE;
                cbDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
                cbDesc.CPUAccessFlags = 0;
                cbDesc.MiscFlags = 0;
                cbDesc.StructureByteStride = 0;

                if (!SUCCEEDED(m_pDevice->CreateBuffer(
                    &cbDesc, &subResourceData, &m_VertexBuffer
                ))) {
                    if (m_VertexBuffer) m_VertexBuffer->Release();
                    m_VertexBuffer = nullptr;
                }

                free(pVertexData);
            }

            {
                size_t size;
                void* so = LoadFromAcsShaderFileInMemory(L"afx_depth_vs_5_0.acs", ShaderCombo_afx_depth_vs_5_0::GetCombo(), size);
                if (so) {
                    m_pDevice->CreateVertexShader(so, size, NULL, &m_VertexShader);
                }
                if (so) free(so);
            }
        }
    }

    void OnTargetEnd() {
        if (m_VertexBuffer) {
            m_VertexBuffer->Release();
            m_VertexBuffer = nullptr;
        }

        if (m_VertexShader) {
            m_VertexShader->Release();
            m_VertexShader = nullptr;
        }

        while (!m_DepthShaderCombos.empty()) {
            auto it = m_DepthShaderCombos.begin();
            it->second->Release();
            m_DepthShaderCombos.erase(it);
        }

        if (m_BlendState) {
            m_BlendState->Release();
            m_BlendState = nullptr;
        }

        if (m_RasterizerState) {
            m_RasterizerState->Release();
            m_RasterizerState = nullptr;
        }

        if (m_DepthStencilState) {
            m_DepthStencilState->Release();
            m_DepthStencilState = nullptr;
        }

        if (m_ConstantBuffer) {
            m_ConstantBuffer->Release();
            m_ConstantBuffer = nullptr;
        }

        if (m_DeviceContext) {
            m_DeviceContext->Release();
            m_DeviceContext = nullptr;
        }

        if (m_pSmokeDepthTextureSrv) {
            m_pSmokeDepthTextureSrv->Release();
            m_pSmokeDepthTextureSrv = nullptr;
        }

        if(m_pSmokeDepthTexture) {
            m_pSmokeDepthTexture->Release();
            m_pSmokeDepthTexture = nullptr;
        }

        if (m_pNormalDepthTextureSrv) {
            m_pNormalDepthTextureSrv->Release();
            m_pNormalDepthTextureSrv = nullptr;
        }

        if (m_pNormalDepthTexture) {
            m_pNormalDepthTexture->Release();
            m_pNormalDepthTexture = nullptr;
        }

        if (m_pDepthTextureRtv) {
            m_pDepthTextureRtv->Release();
            m_pDepthTextureRtv = nullptr;
        }

        if (m_pDepthTexture) {
            m_pDepthTexture->Release();
            m_pDepthTexture = nullptr;
        }

        if(m_pDevice) {
            m_pDevice->Release();
            m_pDevice = nullptr;
        }
    }

    void CaptureSmokeDepth(ID3D11DeviceContext * pContext, ID3D11DepthStencilView * pDepthStencilView) {
        if (!HasCoreDeps() || pContext == nullptr || pDepthStencilView == nullptr) return;

        D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
        pDepthStencilView->GetDesc(&depthStencilViewDesc);

        if(D3D11_DSV_DIMENSION_TEXTURE2D == depthStencilViewDesc.ViewDimension
            //|| D3D11_DSV_DIMENSION_TEXTURE2DMS == depthStencilViewDesc.ViewDimension // usally this is not the case for smoke buffer           
        ) {
            ID3D11Resource * pResource = nullptr;
            pDepthStencilView->GetResource(&pResource);
            if(pResource) {
                ID3D11Texture2D * pTexture = nullptr;
                pResource->QueryInterface(__uuidof(ID3D11Texture2D), (void**)&pTexture);
                if(pTexture) {
                    /*UINT dataSize = 0;
                    if (SUCCEEDED(pTexture->GetPrivateData(WKPDID_D3DDebugObjectName, &dataSize, nullptr))) {
                        isSmokeTexture = true;
                        if (0 < dataSize) {
                            if (char* debugName = (char*)malloc(dataSize + 1)) {
                                if (SUCCEEDED(pTexture->GetPrivateData(WKPDID_D3DDebugObjectName, &dataSize, debugName))) {
                                    debugName[dataSize] = 0;
                                    advancedfx::Message("AFXD3DDEBUG: %s\n", debugName);
                                }
                                free(debugName);
                            }
                        }
                    }*/

                    D3D11_TEXTURE2D_DESC smokeDepthTextureDesc;
                    pTexture->GetDesc(&smokeDepthTextureDesc);

                    if (nullptr != m_pSmokeDepthTexture) {
                        // Check if the texture properties changed in a relevant way that needs updating.
                        if (m_SmokeDepthTextureDesc.Width != smokeDepthTextureDesc.Width
                            || m_SmokeDepthTextureDesc.Height != smokeDepthTextureDesc.Height
                            || m_SmokeDepthTextureDesc.MipLevels != smokeDepthTextureDesc.MipLevels
                            || m_SmokeDepthTextureDesc.Format != smokeDepthTextureDesc.Format
                            || m_SmokeDepthTextureDesc.SampleDesc.Count != smokeDepthTextureDesc.SampleDesc.Count
                            || m_SmokeDepthTextureDesc.SampleDesc.Quality != smokeDepthTextureDesc.SampleDesc.Quality
                            ) {
                            m_pSmokeDepthTexture->Release();
                            m_pSmokeDepthTexture = nullptr;
                        }
                    }

                    if (nullptr == m_pSmokeDepthTexture) {
                        m_SmokeDepthTextureDesc = smokeDepthTextureDesc; // Usally DXGI_FORMAT_R24G8_TYPELESS to expect here.
                        smokeDepthTextureDesc.Format = DXGI_FORMAT_R24G8_TYPELESS;
                        smokeDepthTextureDesc.Usage = D3D11_USAGE_DEFAULT;
                        smokeDepthTextureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
                        smokeDepthTextureDesc.CPUAccessFlags = 0;
                        smokeDepthTextureDesc.MiscFlags = 0;
                        D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc = {};
                        srvbuffer_desc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
                        srvbuffer_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
                        srvbuffer_desc.Texture2D.MipLevels = 1;
                        srvbuffer_desc.Texture2D.MostDetailedMip = 0;
                        m_pDevice->CreateTexture2D(&smokeDepthTextureDesc, nullptr, &m_pSmokeDepthTexture);
                        if (m_pSmokeDepthTexture) {
                            if (m_pSmokeDepthTextureSrv) {
                                m_pSmokeDepthTextureSrv->Release();
                                m_pSmokeDepthTextureSrv = nullptr;
                            }
                            m_pDevice->CreateShaderResourceView(m_pSmokeDepthTexture, &srvbuffer_desc, &m_pSmokeDepthTextureSrv);
                        }
                    }

                    if(m_pSmokeDepthTexture)
                    {
                        UINT numViewPorts = 1;
                        pContext->RSGetViewports(&numViewPorts, &m_SmokeViewPort);

                        ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
                        ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
                        pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pNullDepthStencilView);
                        }

                        pContext->CopyResource(m_pSmokeDepthTexture, pTexture);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);
                        }

                        if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();

                        m_HasSmokeDepth = true;
                    }
                    
                    pTexture->Release();
                }

                pResource->Release();
            }
        }
    }

    void CaptureNormalDepth(ID3D11DeviceContext * pContext, ID3D11DepthStencilView * pDepthStencilView) {
        if (!HasCoreDeps() || pContext == nullptr || pDepthStencilView == nullptr) return;

        D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
        pDepthStencilView->GetDesc(&depthStencilViewDesc);

        if (D3D11_DSV_DIMENSION_TEXTURE2D == depthStencilViewDesc.ViewDimension
            || D3D11_DSV_DIMENSION_TEXTURE2DMS == depthStencilViewDesc.ViewDimension    
            ) {
            ID3D11Resource* pResource = nullptr;
            pDepthStencilView->GetResource(&pResource);
            if (pResource) {
                ID3D11Texture2D* pTexture = nullptr;
                pResource->QueryInterface(__uuidof(ID3D11Texture2D), (void**)&pTexture);
                if (pTexture) {
                    D3D11_TEXTURE2D_DESC normalDepthTextureDesc;
                    pTexture->GetDesc(&normalDepthTextureDesc);

                    if (nullptr != m_pNormalDepthTexture) {
                        // Check if the texture properties changed in a relevant way that needs updating.
                        if (m_NormalDepthTextureDesc.Width != normalDepthTextureDesc.Width
                            || m_NormalDepthTextureDesc.Height != normalDepthTextureDesc.Height
                            || m_NormalDepthTextureDesc.MipLevels != normalDepthTextureDesc.MipLevels
                            || m_NormalDepthTextureDesc.Format != normalDepthTextureDesc.Format
                            || m_NormalDepthTextureDesc.SampleDesc.Count != normalDepthTextureDesc.SampleDesc.Count
                            || m_NormalDepthTextureDesc.SampleDesc.Quality != normalDepthTextureDesc.SampleDesc.Quality
                            ) {
                            m_pNormalDepthTexture->Release();
                            m_pNormalDepthTexture = nullptr;
                        }
                    }

                    if (nullptr == m_pNormalDepthTexture) {
                        m_NormalDepthTextureDesc = normalDepthTextureDesc; // Usally DXGI_FORMAT_R24G8_TYPELESS to expect here.
                        normalDepthTextureDesc.Format = DXGI_FORMAT_R24G8_TYPELESS;
                        normalDepthTextureDesc.Usage = D3D11_USAGE_DEFAULT;
                        normalDepthTextureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
                        normalDepthTextureDesc.CPUAccessFlags = 0;
                        normalDepthTextureDesc.MiscFlags = 0;
                        D3D11_SHADER_RESOURCE_VIEW_DESC srvbuffer_desc = {};
                        srvbuffer_desc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
                        srvbuffer_desc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DMS == depthStencilViewDesc.ViewDimension ? D3D11_SRV_DIMENSION_TEXTURE2DMS : D3D11_SRV_DIMENSION_TEXTURE2D;
                        srvbuffer_desc.Texture2D.MipLevels = 1;
                        srvbuffer_desc.Texture2D.MostDetailedMip = 0;
                        m_pDevice->CreateTexture2D(&normalDepthTextureDesc, nullptr, &m_pNormalDepthTexture);
                        if (m_pNormalDepthTexture) {
                            if (m_pNormalDepthTextureSrv) {
                                m_pNormalDepthTextureSrv->Release();
                                m_pNormalDepthTextureSrv = nullptr;
                            }
                            m_pDevice->CreateShaderResourceView(m_pNormalDepthTexture, &srvbuffer_desc, &m_pNormalDepthTextureSrv);
                        }
                    }

                    if (m_pNormalDepthTexture)
                    {
                        UINT numViewPorts = 1;
                        pContext->RSGetViewports(&numViewPorts, &m_NormalViewPort);

                        ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
                        ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
                        pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pNullDepthStencilView);
                        }

                        pContext->CopyResource(m_pNormalDepthTexture, pTexture);

                        if (pCurrentDepthStencilView == pDepthStencilView) {
                            pContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);
                        }

                        if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();

                        m_HasNormalDepth = true;
                    }

                    if (m_pDepthTextureRtv && m_pNormalDepthTextureSrv)
                    {
                        m_DeviceContext->OMSetRenderTargets(1, &m_pDepthTextureRtv, nullptr);
                        m_DeviceContext->OMSetBlendState(m_BlendState, NULL, 0xffffffff);                        

                        UINT numViewPorts = 1;
                        m_DeviceContext->RSSetViewports(1, &m_NormalViewPort);

                        SOURCESDK::VMatrix projectionMatrix;
                        g_RenderSystemDrawingData.GetProjectionMatrix(projectionMatrix);

                        double M[4][4] = {
                            projectionMatrix.m[0][0], projectionMatrix.m[0][1], projectionMatrix.m[0][2],  projectionMatrix.m[0][3],
                            projectionMatrix.m[1][0], projectionMatrix.m[1][1], projectionMatrix.m[1][2],  projectionMatrix.m[1][3],
                            projectionMatrix.m[2][0], projectionMatrix.m[2][1], projectionMatrix.m[2][2],  projectionMatrix.m[2][3],
                            projectionMatrix.m[3][0], projectionMatrix.m[3][1], projectionMatrix.m[3][2],  projectionMatrix.m[3][3]
                        };

                        double b0[4] = { 1, 0, 0, 0 };
                        double b1[4] = { 0, 1, 0, 0 };
                        double b2[4] = { 0, 0, 1, 0 };
                        double b3[4] = { 0, 0, 0, 1 };

                        unsigned char P[4];
                        unsigned char Q[4];

                        double L[4][4];
                        double U[4][4];

                        FLOAT newMatrix[4][4];
                        FLOAT zNear = g_ViewPort.MinDepth;
                        FLOAT zFar = g_ViewPort.MaxDepth;
                        FLOAT zNormalNear = projectionMatrix.m[2][3] / projectionMatrix.m[2][2];
                        FLOAT zNormalFar = projectionMatrix.m[2][3] / (projectionMatrix.m[2][2] + 1);

                        if (LUdecomposition(M, P, Q, L, U))
                        {
                            double inv0[4] = { 1,0,0,0 };
                            double inv1[4] = { 0,1,0,0 };
                            double inv2[4] = { 0,0,1,0 };
                            double inv3[4] = { 0,0,0,1 };

                            SolveWithLU(L, U, P, Q, b0, inv0);
                            SolveWithLU(L, U, P, Q, b1, inv1);
                            SolveWithLU(L, U, P, Q, b2, inv2);
                            SolveWithLU(L, U, P, Q, b3, inv3);

                            // Transposed for DirectX:
                            newMatrix[0][0] = (FLOAT)inv0[0]; newMatrix[0][1] = (FLOAT)inv0[1]; newMatrix[0][2] = (FLOAT)inv0[2]; newMatrix[0][3] = (FLOAT)inv0[3];
                            newMatrix[1][0] = (FLOAT)inv1[0]; newMatrix[1][1] = (FLOAT)inv1[1]; newMatrix[1][2] = (FLOAT)inv1[2]; newMatrix[1][3] = (FLOAT)inv1[3];
                            newMatrix[2][0] = (FLOAT)inv2[0]; newMatrix[2][1] = (FLOAT)inv2[1]; newMatrix[2][2] = (FLOAT)inv2[2]; newMatrix[2][3] = (FLOAT)inv2[3];
                            newMatrix[3][0] = (FLOAT)inv3[0]; newMatrix[3][1] = (FLOAT)inv3[1]; newMatrix[3][2] = (FLOAT)inv3[2]; newMatrix[3][3] = (FLOAT)inv3[3];
                        }
                        else {
                            newMatrix[0][0] = 1; newMatrix[0][1] = 0; newMatrix[0][2] = 0; newMatrix[0][3] = 0;
                            newMatrix[1][0] = 0; newMatrix[1][1] = 1; newMatrix[1][2] = 0; newMatrix[1][3] = 0;
                            newMatrix[2][0] = 0; newMatrix[2][1] = 0; newMatrix[2][2] = 1; newMatrix[2][3] = 0;
                            newMatrix[3][0] = 0; newMatrix[3][1] = 0; newMatrix[3][2] = 0; newMatrix[3][3] = 1;
                        }

                        int skyBoxScale = 16;
                        FLOAT zSkyNear = 2.0f * skyBoxScale;
                        FLOAT zSkyFar = (float)(1.732050807569 * 2 * 16384 * skyBoxScale);

                        CS_CONSTANT_BUFFER constant_buffer = {
                            zNormalNear,
                            zNormalFar,
                            zNormalNear,
                            zNormalFar,
                            zNear,
                            zFar,
                            zSkyNear,
                            zSkyFar,
                            (int)g_ViewPort.Width,
                            (int)g_ViewPort.Height,
                            (int)m_DeviceTextureDesc.Width,
                            (int)m_DeviceTextureDesc.Height,
                            {
                                newMatrix[0][0], newMatrix[0][1], newMatrix[0][2], newMatrix[0][3],
                                newMatrix[1][0], newMatrix[1][1], newMatrix[1][2], newMatrix[1][3],
                                newMatrix[2][0], newMatrix[2][1], newMatrix[2][2], newMatrix[2][3],
                                newMatrix[3][0], newMatrix[3][1], newMatrix[3][2], newMatrix[3][3]
                            }
                        };
                        {
                            D3D11_MAPPED_SUBRESOURCE mappedResource;
                            if (SUCCEEDED(m_DeviceContext->Map(m_ConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource))) {
                                memcpy(mappedResource.pData, &constant_buffer, sizeof(constant_buffer));
                                m_DeviceContext->Unmap(m_ConstantBuffer, 0);
                            }
                        }
                        m_DeviceContext->PSSetConstantBuffers(0, 1, &m_ConstantBuffer);

                        bool multisampled = 1 < m_NormalDepthTextureDesc.SampleDesc.Count;
                        bool compositeSmoke = m_HasSmokeDepth && m_pSmokeDepthTextureSrv;

                        int shaderCombo = ShaderCombo_afx_depth_ps_5_0::GetCombo(
                            multisampled ? ShaderCombo_afx_depth_ps_5_0::AFXMS_1 : ShaderCombo_afx_depth_ps_5_0::AFXMS_0,
                            compositeSmoke ? ShaderCombo_afx_depth_ps_5_0::AFXSMOKE_1 : ShaderCombo_afx_depth_ps_5_0::AFXSMOKE_0,
                            ShaderCombo_afx_depth_ps_5_0::AFXDEPTHMODE_0,
                            ShaderCombo_afx_depth_ps_5_0::AFXD24_0
                        );

                        ID3D11PixelShader * pPixelShader = nullptr;
                        auto it = m_DepthShaderCombos.find(shaderCombo);
                        if (it != m_DepthShaderCombos.end())
                            pPixelShader = it->second;
                        else {
                            size_t size;
                            void* so = LoadFromAcsShaderFileInMemory(L"afx_depth_ps_5_0.acs", shaderCombo, size);

                            if (so) {
                                m_pDevice->CreatePixelShader(so, size, NULL, &pPixelShader);
                            }
                            if (so) free(so);

                            m_DepthShaderCombos[shaderCombo] = pPixelShader;
                        }
                        if (pPixelShader) {
                            m_DeviceContext->PSSetShaderResources(0, 1, &m_pNormalDepthTextureSrv);
                            if(compositeSmoke) m_DeviceContext->PSSetShaderResources(1, 1, &m_pSmokeDepthTextureSrv);

                            m_DeviceContext->VSSetShader(m_VertexShader, nullptr, 0);
                            m_DeviceContext->PSSetShader(pPixelShader, nullptr, 0);

                            UINT stride = sizeof(Vertex);
                            UINT offset = 0;
                            m_DeviceContext->IASetVertexBuffers(0, 1, &m_VertexBuffer, &stride, &offset);

                            UINT startVertex = 0;
                            // Draw quad:
                            m_DeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
                            m_DeviceContext->Draw(4, startVertex);

                            m_HasNormalDepth = true;
                        }

                        //

                        ID3D11CommandList* pCommandList = nullptr;
                        m_DeviceContext->FinishCommandList(FALSE, &pCommandList);
                        if (pCommandList) {
                            pContext->ExecuteCommandList(pCommandList,
                                TRUE // RestoreContextState has quite some performance impact on TRUE, let's try FALSE first
                            );
                            pCommandList->Release();
                        }
                    }

                    pTexture->Release();
                }

                pResource->Release();
            }
        }
    }

    ID3D11Resource * GetDepthResource() {
        if (m_HasNormalDepth) {
            if (m_pDepthTexture) m_pDepthTexture->AddRef();
            return m_pDepthTexture;
        }
        return nullptr;
    }

    void OnPresent() {
        m_HasSmokeDepth = false;
        m_HasNormalDepth = false;
    }

private:
    ID3D11Device * m_pDevice = nullptr;
    D3D11_TEXTURE2D_DESC m_DeviceTextureDesc = {};
    ID3D11Texture2D * m_pSmokeDepthTexture = nullptr;
    ID3D11ShaderResourceView* m_pSmokeDepthTextureSrv = nullptr;
    D3D11_TEXTURE2D_DESC m_SmokeDepthTextureDesc = {};
    D3D11_VIEWPORT m_SmokeViewPort = {};
    bool m_HasSmokeDepth = false;
    ID3D11ShaderResourceView* m_pNormalDepthTextureSrv = nullptr;
    ID3D11Texture2D* m_pNormalDepthTexture = nullptr;
    D3D11_TEXTURE2D_DESC m_NormalDepthTextureDesc = {};
    ID3D11Texture2D* m_pDepthTexture = nullptr;
    ID3D11RenderTargetView* m_pDepthTextureRtv = nullptr;
    D3D11_VIEWPORT m_NormalViewPort = {};
    bool m_HasNormalDepth = false;

    ID3D11DeviceContext* m_DeviceContext = nullptr;

    struct CS_CONSTANT_BUFFER {
        float cZNear;
        float cZFar;
        float cOutNear;
        float cOutFar;
        float cNormalFar;
        float unused_c1y;
        float cSkyNear;
        float cSkyFar;
        int cViewportWidth;
        int cViewportHeight;
        int cWidth;
        int cHeight;
        DirectX::XMFLOAT4X4 invViewProj;
    };
    ID3D11Buffer* m_ConstantBuffer = nullptr;

    std::map<int, ID3D11PixelShader*> m_DepthShaderCombos;

    ID3D11VertexShader* m_VertexShader = nullptr;

    struct Vertex
    {
        FLOAT x, y, z;
    };
    ID3D11Buffer* m_VertexBuffer = nullptr;

    ID3D11DepthStencilState* m_DepthStencilState = nullptr;

    ID3D11RasterizerState* m_RasterizerState = nullptr;

    ID3D11BlendState* m_BlendState = nullptr;

    bool HasCoreDeps() {
        return m_pDevice && m_DeviceContext && m_ConstantBuffer && m_VertexBuffer && m_VertexShader && m_DepthStencilState && m_RasterizerState && m_BlendState && m_pDepthTexture && m_pDepthTextureRtv;
    }
} g_DepthCompositor;


IDXGISwapChain * g_pSwapChain = nullptr;
ID3D11Device * g_pDevice = nullptr;
ID3D11DeviceContext * g_pImmediateContext = nullptr;
ID3D11DeviceContext * g_pOtherContext = nullptr;
ID3D11RenderTargetView* g_pRTView = nullptr;
int g_iDraw = 0;
bool g_bInOwnDraw = false;
ID3D11Resource* g_pMainRenderTargetResource = nullptr;
bool g_bDetectSmoke = false;
bool g_bDetectedSmoke = false;
ID3D11DepthStencilView* g_pSmokeDepthStencilView = nullptr;

enum class ViewPass_e {
    None = 0,
    BeforeGameOverlay = 1
};

struct ViewPasses_s {
public:
    std::queue<ViewPass_e> Queue;
};

extern void ErrorBox(char const * messageText);

class CAfxShaderResourceViews {
public:
    static ID3D11ShaderResourceView* GetView(ID3D11Resource* pResource) {
        std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        auto result = m_Resource2View.find(pResource);
        if (result != m_Resource2View.end())
            return result->second;
        return nullptr;
    }

    static ID3D11Resource* GetResource(ID3D11ShaderResourceView* pView) {
        std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        auto result = m_View2Resource.find(pView);
        if (result != m_View2Resource.end())
            return result->second;
        return nullptr;
    }


    static void Hook(ID3D11Resource* pResource, ID3D11ShaderResourceView* pShaderResourceView) {
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
            if (m_View2Resource.find(pShaderResourceView) != m_View2Resource.end()) return;
        }
        std::unique_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        if (!m_View2Resource.emplace(pShaderResourceView, pResource).second) return;
        m_Resource2View.emplace(pResource, pShaderResourceView);
        HookVtable(pShaderResourceView);
    }

    static void Clear() {
        std::unique_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        m_Resource2View.clear();
        m_View2Resource.clear();
    }

private:
    static std::shared_timed_mutex m_SharedMutex;
    static std::map<ID3D11Resource*, ID3D11ShaderResourceView*> m_Resource2View;
    static std::map<ID3D11ShaderResourceView*, ID3D11Resource*> m_View2Resource;

    typedef ULONG(STDMETHODCALLTYPE* Release_t)(IUnknown* pThis);

    static std::shared_timed_mutex m_VtableSharedMutex;
    static std::map<Release_t, Release_t> m_VtableHooks;

    static void OnDelete(IUnknown* pThis) {
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_SharedMutex);
            if (m_View2Resource.find(static_cast<ID3D11ShaderResourceView*>(pThis)) == m_View2Resource.end()) return;
        }
        std::unique_lock<std::shared_timed_mutex> lock(m_SharedMutex);
        auto result = m_View2Resource.find(static_cast<ID3D11ShaderResourceView*>(pThis));
        if (result == m_View2Resource.end()) return;
        m_Resource2View.erase(result->second);
        m_View2Resource.erase(result);
    }

    static ULONG STDMETHODCALLTYPE NewRelease(IUnknown* pThis) {
        void** vtable = *(void***)pThis;
        Release_t pRelease = (Release_t)vtable[2];
        ULONG result;
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_VtableSharedMutex);
            result = m_VtableHooks.find(pRelease)->second(pThis);
        }
        if (0 == result) {
            OnDelete(pThis);
        }
        return result;
    }

    static void HookVtable(IUnknown* pUnknown) {
        void** vtable = *(void***)pUnknown;
        Release_t pRelease = (Release_t)vtable[2];
        {
            std::shared_lock<std::shared_timed_mutex> lock(m_VtableSharedMutex);
            if (m_VtableHooks.find(pRelease) != m_VtableHooks.end()) return;
        }
        std::unique_lock<std::shared_timed_mutex> lock(m_VtableSharedMutex);
        if (m_VtableHooks.find(pRelease) != m_VtableHooks.end()) return;

        Release_t oldRelease = pRelease;
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)pRelease, NewRelease);
        if (NO_ERROR != DetourTransactionCommit()) {
            ErrorBox("CAfxShaderResourceViews::HookVtable Failed hooking on IUnknown.");
        } else m_VtableHooks.emplace(oldRelease, pRelease);
    }
};

std::shared_timed_mutex CAfxShaderResourceViews::m_SharedMutex;
std::map<ID3D11Resource*, ID3D11ShaderResourceView*> CAfxShaderResourceViews::m_Resource2View;
std::map<ID3D11ShaderResourceView*, ID3D11Resource*> CAfxShaderResourceViews::m_View2Resource;
std::shared_timed_mutex CAfxShaderResourceViews::m_VtableSharedMutex;
std::map<CAfxShaderResourceViews::Release_t, CAfxShaderResourceViews::Release_t> CAfxShaderResourceViews::m_VtableHooks;

typedef HRESULT (STDMETHODCALLTYPE * CreateShaderResourceView_t)(ID3D11Device* This,
    /* [annotation] */
    _In_  ID3D11Resource* pResource,
    /* [annotation] */
    _In_opt_  const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,
    /* [annotation] */
    _COM_Outptr_opt_  ID3D11ShaderResourceView** ppSRView);

CreateShaderResourceView_t g_Old_CreateShaderResourceView = nullptr;

HRESULT STDMETHODCALLTYPE New_CreateShaderResourceView(ID3D11Device* This,
    /* [annotation] */
    _In_  ID3D11Resource* pResource,
    /* [annotation] */
    _In_opt_  const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,
    /* [annotation] */
    _COM_Outptr_opt_  ID3D11ShaderResourceView** ppSRView) {
    HRESULT result = g_Old_CreateShaderResourceView(This, pResource, pDesc, ppSRView);

    if (SUCCEEDED(result) && pResource && pDesc && ppSRView && *ppSRView) {
        CAfxShaderResourceViews::Hook(pResource, *ppSRView);
    }

    return result;
}

typedef HRESULT (STDMETHODCALLTYPE * CreateRenderTargetView_t)( ID3D11Device * This,
            /* [annotation] */ 
            _In_  ID3D11Resource *pResource,
            /* [annotation] */ 
            _In_opt_  const D3D11_RENDER_TARGET_VIEW_DESC *pDesc,
            /* [annotation] */ 
            _COM_Outptr_opt_  ID3D11RenderTargetView **ppRTView);

CreateRenderTargetView_t g_Old_CreateRenderTargetView = nullptr;

HRESULT STDMETHODCALLTYPE New_CreateRenderTargetView(  ID3D11Device * This,
            /* [annotation] */ 
            _In_  ID3D11Resource *pResource,
            /* [annotation] */ 
            _In_opt_  const D3D11_RENDER_TARGET_VIEW_DESC *pDesc,
            /* [annotation] */ 
            _COM_Outptr_opt_  ID3D11RenderTargetView **ppRTView) {
    
    HRESULT result = g_Old_CreateRenderTargetView(This, pResource, pDesc, ppRTView);

    if (SUCCEEDED(result) && ppRTView && *ppRTView
    &&g_pSwapChain // can be nullptr e.g. when people forget to "disable service" on FACEIT anti cheat.
    ) {
        ID3D11Texture2D * pTexture = nullptr;
        HRESULT result2 = g_pSwapChain->GetBuffer(0,__uuidof(ID3D11Texture2D), (void**)&pTexture);
        if(SUCCEEDED(result2)) {
            if(pResource == pTexture/* && (g_pDevice == nullptr || This != g_pDevice)*/) {
                if(g_pDevice) {
                    g_DepthCompositor.OnTargetEnd();
                    CAfxShaderResourceViews::Clear();
                    g_CampathDrawer.EndDevice();
                    g_pDevice->Release();
                    g_pDevice = nullptr;
                }
                g_DepthCompositor.OnTargetBegin(This, pTexture);
                g_iDraw = 0;
                g_pRTView = *ppRTView;
                g_pMainRenderTargetResource = nullptr;
                g_pDevice = This;
                g_pDevice->AddRef();
                g_CampathDrawer.BeginDevice(This);
            }
            pTexture->Release();
        }
    }

    return result;
}

typedef void (STDMETHODCALLTYPE * ClearDepthStencilView_t)( ID3D11DeviceContext * This, 
    /* [annotation] */ 
    _In_  ID3D11DepthStencilView *pDepthStencilView,
    /* [annotation] */ 
    _In_  UINT ClearFlags,
    /* [annotation] */ 
    _In_  FLOAT Depth,
    /* [annotation] */ 
    _In_  UINT8 Stencil);

ClearDepthStencilView_t g_Old_ClearDepthStencilView = nullptr;

ID3D11RenderTargetView * g_pCurrentRenderTargetView = nullptr;
ID3D11DepthStencilView * g_pCurrentDepthStencilView = nullptr;

void STDMETHODCALLTYPE New_ClearDepthStencilView( ID3D11DeviceContext * This, 
    _In_  ID3D11DepthStencilView *pDepthStencilView,
    /* [annotation] */ 
    _In_  UINT ClearFlags,
    /* [annotation] */ 
    _In_  FLOAT Depth,
    /* [annotation] */ 
    _In_  UINT8 Stencil) {

    if (This == g_pImmediateContext && g_bInOwnDraw == false) {

        /*if (g_bDetectedSmoke && pDepthStencilView == g_pSmokeDepthStencilView) {
            g_bDetectedSmoke = false;
            ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
            ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
            g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

            if (pDepthStencilView && pDepthStencilView == pCurrentDepthStencilView)
                g_pImmediateContext->OMSetRenderTargets(0, nullptr, nullptr);

            g_DepthCompositor.CaptureSmokeDepth(g_pImmediateContext, g_pSmokeDepthStencilView);

            if (pDepthStencilView && pDepthStencilView == pCurrentDepthStencilView)
                g_pImmediateContext->OMSetRenderTargets(0, nullptr, pCurrentDepthStencilView);

            if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();
        }*/
    }

    g_Old_ClearDepthStencilView(This, pDepthStencilView, ClearFlags, Depth, Stencil);
}

typedef void (STDMETHODCALLTYPE * ResolveSubresource_t)( ID3D11DeviceContext * This,
    /* [annotation] */ 
    _In_  ID3D11Resource *pDstResource,
    /* [annotation] */ 
    _In_  UINT DstSubresource,
    /* [annotation] */ 
    _In_  ID3D11Resource *pSrcResource,
    /* [annotation] */ 
    _In_  UINT SrcSubresource,
    /* [annotation] */ 
    _In_  DXGI_FORMAT Format);

ResolveSubresource_t g_Old_ResolveSubresource = nullptr;

void STDMETHODCALLTYPE New_ResolveSubresource( ID3D11DeviceContext * This,
    /* [annotation] */ 
    _In_  ID3D11Resource *pDstResource,
    /* [annotation] */ 
    _In_  UINT DstSubresource,
    /* [annotation] */ 
    _In_  ID3D11Resource *pSrcResource,
    /* [annotation] */ 
    _In_  UINT SrcSubresource,
    /* [annotation] */ 
    _In_  DXGI_FORMAT Format) {

    if(This == g_pImmediateContext && g_bInOwnDraw == false) {
        g_pMainRenderTargetResource = pSrcResource;
    }

    g_Old_ResolveSubresource(This, pDstResource, DstSubresource, pSrcResource, SrcSubresource, Format);
 }


typedef void (STDMETHODCALLTYPE * OMSetRenderTargets_t)( ID3D11DeviceContext * This,
            /* [annotation] */ 
            _In_range_( 0, D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT )  UINT NumViews,
            /* [annotation] */ 
            _In_reads_opt_(NumViews)  ID3D11RenderTargetView *const *ppRenderTargetViews,
            /* [annotation] */ 
            _In_opt_  ID3D11DepthStencilView *pDepthStencilView);

OMSetRenderTargets_t g_Old_OMSetRenderTargets = nullptr;

void STDMETHODCALLTYPE New_OMSetRenderTargets( ID3D11DeviceContext * This,
            /* [annotation] */ 
            _In_range_( 0, D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT )  UINT NumViews,
            /* [annotation] */ 
            _In_reads_opt_(NumViews)  ID3D11RenderTargetView *const *ppRenderTargetViews,
            /* [annotation] */ 
            _In_opt_  ID3D11DepthStencilView *pDepthStencilView) {       
    if (!g_bInOwnDraw && This->GetType() == D3D11_DEVICE_CONTEXT_IMMEDIATE) {
        if (NumViews >= 1) {
            if (g_iDraw == 0 && pDepthStencilView && ppRenderTargetViews && ppRenderTargetViews[0]) {
                g_iDraw = 2;

                g_pImmediateContext = This;
                g_pCurrentDepthStencilView = pDepthStencilView;
                g_pCurrentRenderTargetView = ppRenderTargetViews[0];
            }
            else if (g_iDraw == 2 && pDepthStencilView == nullptr && ppRenderTargetViews && ppRenderTargetViews[0] && ppRenderTargetViews[0] == g_pCurrentRenderTargetView) {
                g_iDraw = 3;

                g_bInOwnDraw = true;

                UINT numViewPorts = 1;
                g_pImmediateContext->RSGetViewports(&numViewPorts, &g_ViewPort);

                g_CampathDrawer.OnRenderThread_Draw(g_pImmediateContext, &g_ViewPort, g_pCurrentRenderTargetView, g_pCurrentDepthStencilView);

                g_bInOwnDraw = false;
            }
        }         
        if (g_bDetectSmoke && pDepthStencilView) {
            static int count;
            if (!g_bDetectedSmoke) {
                g_bDetectedSmoke = true;
                count = 0;
            }
            //advancedfx::Message("Smoke: %i\n", count);
            if (2 == count) {
                g_pSmokeDepthStencilView = pDepthStencilView;
            }
            count++;
        }
    }

    g_Old_OMSetRenderTargets(This, NumViews, ppRenderTargetViews, pDepthStencilView);
}

class IRenderThreadCallback abstract {
public:
    virtual void OnCallback(void) abstract = 0;
};



class CAfxRenderCallbackBeforeClearSmokeTargets1 : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackBeforeClearSmokeTargets1()
    {
    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            g_bDetectSmoke = true;
            g_bDetectedSmoke = false;
            g_pSmokeDepthStencilView = nullptr;
        }
        delete this;
    }
private:
};


class CAfxRenderCallbackAfterClearSmokeTargets1 : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackAfterClearSmokeTargets1()
    {
    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            g_bDetectSmoke = false;
        }
        delete this;
    }
private:
};

class CAfxRenderCallbackAfterMaybeSmokeDrawn : public IRenderThreadCallback
{
public:
    CAfxRenderCallbackAfterMaybeSmokeDrawn()
    {
    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            g_bDetectSmoke = false;
            if (g_bDetectedSmoke && g_pSmokeDepthStencilView) {
                ID3D11DepthStencilView* pCurrentDepthStencilView = nullptr;
                ID3D11DepthStencilView* pNullDepthStencilView = nullptr;
                g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);

                if (pCurrentDepthStencilView == g_pSmokeDepthStencilView) {
                    g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pNullDepthStencilView);
                }

                g_DepthCompositor.CaptureSmokeDepth(g_pImmediateContext, g_pSmokeDepthStencilView);

                if (pCurrentDepthStencilView == g_pSmokeDepthStencilView) {
                    g_pImmediateContext->OMGetRenderTargets(0, nullptr, &pCurrentDepthStencilView);
                }

                if (pCurrentDepthStencilView) pCurrentDepthStencilView->Release();

                g_pSmokeDepthStencilView = nullptr;
            }
        }
        delete this;
    }
private:
};

class CAfxRenderViewCallback : public IRenderThreadCallback
{
public:
    CAfxRenderViewCallback()
    {

    }

    virtual void OnCallback(void) {
        if (g_pImmediateContext) {
            g_bDetectSmoke = false;
            if (g_ReShadeAdvancedfx.IsConnected() && g_bEnableReShade) {
                g_DepthCompositor.CaptureNormalDepth(g_pImmediateContext, g_pCurrentDepthStencilView);

                ID3D11RenderTargetView* pRenderTargetViews[1] = { nullptr };
                ID3D11DepthStencilView* pDepthStencilView = nullptr;
                g_pImmediateContext->OMGetRenderTargets(1, &pRenderTargetViews[0], &pDepthStencilView);

                ID3D11Resource* pRenderTargetViewResource = nullptr;
                //ID3D11Resource* pDepthStencilResource = nullptr;
                if (pRenderTargetViews[0]) pRenderTargetViews[0]->GetResource(&pRenderTargetViewResource);
                //if (g_pCurrentDepthStencilView) g_pCurrentDepthStencilView->GetResource(&pDepthStencilResource);

                if (ID3D11Resource* pResource = g_DepthCompositor.GetDepthResource()) {
                    g_bInOwnDraw = true;
                    g_ReShadeAdvancedfx.AdvancedfxRenderEffects(pRenderTargetViewResource, pResource);
                    g_bInOwnDraw = false;
                    pResource->Release();
                }

                //if (pDepthStencilResource) pDepthStencilResource->Release();
                if (pRenderTargetViewResource) pRenderTargetViewResource->Release();

                if (pDepthStencilView) pDepthStencilView->Release();
                if (pRenderTargetViews[0]) pRenderTargetViews[0]->Release();
            }
        }
        delete this;
    }
private:
};


typedef void (STDMETHODCALLTYPE * PSSetShaderResources_t)(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1)  UINT StartSlot,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot)  UINT NumViews,
    /* [annotation] */
    _In_reads_opt_(NumViews)  ID3D11ShaderResourceView* const* ppShaderResourceViews);

PSSetShaderResources_t g_Old_PSSetShaderResources = nullptr;

void STDMETHODCALLTYPE New_PSSetShaderResources(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1)  UINT StartSlot,
    /* [annotation] */
    _In_range_(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - StartSlot)  UINT NumViews,
    /* [annotation] */
    _In_reads_opt_(NumViews)  ID3D11ShaderResourceView* const* ppShaderResourceViews) {

    /*if (This == g_pImmediateContext && g_iDraw == 6 && NumViews >= 1 && ppShaderResourceViews && ppShaderResourceViews[0]) {
        g_iDraw = 6;
        auto pResource = CAfxShaderResourceViews::GetResource(ppShaderResourceViews[0]);
        if (pResource) {
            if (g_ReShadeAdvancedfx.IsConnected() && g_bEnableReShade) {
                ID3D11Resource* pDepthStencilResource = nullptr;
                if (g_pCurrentDepthStencilView) g_pCurrentDepthStencilView->GetResource(&pDepthStencilResource);
                g_bInOwnDraw = true;
                g_ReShadeAdvancedfx.AdvancedfxRenderEffects(pResource, pDepthStencilResource);
                g_bInOwnDraw = false;
                if (pDepthStencilResource) pDepthStencilResource->Release();
            }
        }
    }*/

    return g_Old_PSSetShaderResources(This, StartSlot, NumViews, ppShaderResourceViews);
}

typedef void (STDMETHODCALLTYPE *PSSetShader_t)(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_opt_  ID3D11PixelShader* pPixelShader,
    /* [annotation] */
    _In_reads_opt_(NumClassInstances)  ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances);

PSSetShader_t g_Old_PSSetShader = nullptr;


void STDMETHODCALLTYPE New_PSSetShader(ID3D11DeviceContext* This,
    /* [annotation] */
    _In_opt_  ID3D11PixelShader* pPixelShader,
    /* [annotation] */
    _In_reads_opt_(NumClassInstances)  ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances) {

    /*if (This == g_pImmediateContext) {
        if (g_iDraw == 5 && pPixelShader && nullptr == ppClassInstances && NumClassInstances == 0) {
            const char* pKey = "post_process.vfx_ps";
            const size_t keyLen = 19;
            char buffer[19];
            UINT dataSize = keyLen;
            if (SUCCEEDED(pPixelShader->GetPrivateData(WKPDID_D3DDebugObjectName, &dataSize, &buffer))
                && dataSize == keyLen) {
                size_t i = 0;
                while (true) {
                    if (pKey[i] != buffer[i]) break;
                    i++;
                    if (i == keyLen) {
                        g_iDraw++;
                        break;
                    }
                }
            }
        }
    }*/

    g_Old_PSSetShader(This, pPixelShader, ppClassInstances, NumClassInstances);
}

void Hook_Context(ID3D11DeviceContext * pDeviceContext) {
    static void **last_vtable = nullptr;
    void **vtable = *(void***)pDeviceContext;

    // (We can not use vtable detours here, becuse something writes them back after we did that.)

    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    if(last_vtable) {
        DetourDetach(&(PVOID&)g_Old_PSSetShaderResources, New_PSSetShaderResources);
        DetourDetach(&(PVOID&)g_Old_PSSetShader, New_PSSetShader);
        DetourDetach(&(PVOID&)g_Old_OMSetRenderTargets, New_OMSetRenderTargets);
        DetourDetach(&(PVOID&)g_Old_ClearDepthStencilView, New_ClearDepthStencilView);
        DetourDetach(&(PVOID&)g_Old_ResolveSubresource, New_ResolveSubresource);
        if(NO_ERROR != DetourTransactionCommit()) {
            ErrorBox("Failed detaching on ID1D11RenderContext.");
        }
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
    }
    g_Old_PSSetShaderResources = (PSSetShaderResources_t)vtable[8];
    g_Old_PSSetShader = (PSSetShader_t)vtable[9];
    g_Old_OMSetRenderTargets = (OMSetRenderTargets_t)vtable[33];
    g_Old_ClearDepthStencilView = (ClearDepthStencilView_t)vtable[53];
    g_Old_ResolveSubresource = (ResolveSubresource_t)vtable[57];
    DetourAttach(&(PVOID&)g_Old_PSSetShaderResources, New_PSSetShaderResources);
    DetourAttach(&(PVOID&)g_Old_PSSetShader, New_PSSetShader);
    DetourAttach(&(PVOID&)g_Old_OMSetRenderTargets, New_OMSetRenderTargets);
    DetourAttach(&(PVOID&)g_Old_ClearDepthStencilView, New_ClearDepthStencilView);
    DetourAttach(&(PVOID&)g_Old_ResolveSubresource, New_ResolveSubresource);
    if(NO_ERROR != DetourTransactionCommit()) {
        ErrorBox("Failed attaching on ID1D11RenderContext.");
    }

    last_vtable = vtable;   
}

typedef HRESULT(WINAPI* D3D11CreateDevice_t)(IDXGIAdapter*,D3D_DRIVER_TYPE,HMODULE,UINT,const D3D_FEATURE_LEVEL*,UINT,UINT,ID3D11Device**,D3D_FEATURE_LEVEL*,ID3D11DeviceContext**);
D3D11CreateDevice_t g_Old_D3D11CreateDevice = nullptr;

HRESULT WINAPI New_D3D11CreateDevice(
    IDXGIAdapter *pAdapter,
    D3D_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    const D3D_FEATURE_LEVEL *pFeatureLevels,
    UINT FeatureLevels,
    UINT SDKVersion,
    ID3D11Device **ppDevice,
    D3D_FEATURE_LEVEL *pFeatureLevel,
    ID3D11DeviceContext **ppImmediateContext
    ) {

#ifdef _DEBUG
    //Flags = Flags | D3D11_CREATE_DEVICE_DEBUG;
#endif
    HRESULT result = g_Old_D3D11CreateDevice(
        pAdapter, DriverType, Software, Flags, pFeatureLevels, FeatureLevels, SDKVersion, ppDevice, pFeatureLevel, ppImmediateContext);

    if(SUCCEEDED(result) && ppDevice && *ppDevice) {
        static void **last_vtable = nullptr;
        void **vtable = *(void***)*ppDevice;
        // (We can not use vtable detours here, becuse something writes them back after we New_CreateRenderTargetViewdid that.)
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        if(last_vtable) {
            DetourDetach(&(PVOID&)g_Old_CreateShaderResourceView, New_CreateShaderResourceView);
            DetourDetach(&(PVOID&)g_Old_CreateRenderTargetView, New_CreateRenderTargetView);
            if(NO_ERROR != DetourTransactionCommit()) {
                ErrorBox("Failed detaching in D3D11CreateDevice.");
            }
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());
        }
        g_Old_CreateShaderResourceView = (CreateShaderResourceView_t)vtable[7];
        g_Old_CreateRenderTargetView = (CreateRenderTargetView_t)vtable[9];
        DetourAttach(&(PVOID&)g_Old_CreateShaderResourceView, New_CreateShaderResourceView);
        DetourAttach(&(PVOID&)g_Old_CreateRenderTargetView, New_CreateRenderTargetView);
        if(NO_ERROR != DetourTransactionCommit()) {
            ErrorBox("Failed attaching in D3D11CreateDevice.");
        }
        last_vtable = vtable;

        ID3D11DeviceContext * pContext = nullptr;
        (*ppDevice)->GetImmediateContext(&pContext);
        if(pContext) {
            Hook_Context(pContext);
            pContext->Release();
        }
    }

    return result;
}

typedef HRESULT (STDMETHODCALLTYPE * Present_t)( void * This,
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags);

Present_t g_OldPresent = nullptr;

HRESULT STDMETHODCALLTYPE New_Present( void * This,
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags) {
 
    g_bInOwnDraw = true;

    g_CampathDrawer.OnRenderThread_Present();

    if (g_ReShadeAdvancedfx.IsConnected() && !g_ReShadeAdvancedfx.HasRendered()) {
        g_ReShadeAdvancedfx.AdvancedfxRenderEffects(nullptr, nullptr);
    }

    {
        std::unique_lock<std::mutex> lock(g_SwapChainMutex);

        if(!g_SwapchainBeforePresentQueue.empty()) {
            ID3D11Texture2D * pTexture = nullptr;
            if(g_pSwapChain) g_pSwapChain->GetBuffer(0,__uuidof(ID3D11Texture2D), (void**)&pTexture);
            while(!g_SwapchainBeforePresentQueue.empty()) {
                bool bBreak = g_SwapchainBeforePresentQueue.front()(g_pImmediateContext,pTexture);
                g_SwapchainBeforePresentQueue.pop();
                if(bBreak) break;
            }
            if(pTexture) pTexture->Release();
        }
    }

    HRESULT result = g_OldPresent(This, SyncInterval, Flags);


    {
        std::unique_lock<std::mutex> lock(g_SwapChainMutex);
        
        while(!g_SwapchainAfterPresentQueue.empty()) {
            bool bBreak = g_SwapchainAfterPresentQueue.front()(g_pImmediateContext);
            g_SwapchainAfterPresentQueue.pop();
            if(bBreak) break;
        }
    }

	g_ReShadeAdvancedfx.ResetHasRendered();

    g_DepthCompositor.OnPresent();

    g_RenderSystemDrawingData.Pop();

    g_bInOwnDraw = false;

    g_iDraw = 0;

    return result;
}


typedef HRESULT (STDMETHODCALLTYPE * CreateSwapChain_t)( void * This,
            /* [annotation][in] */ 
            _In_  IUnknown *pDevice,
            /* [annotation][in] */ 
            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
            /* [annotation][out] */ 
            _COM_Outptr_  IDXGISwapChain **ppSwapChain);

CreateSwapChain_t g_OldCreateSwapChain = nullptr;

HRESULT STDMETHODCALLTYPE New_CreateSwapChain( void * This,
            /* [annotation][in] */ 
            _In_  IUnknown *pDevice,
            /* [annotation][in] */ 
            _In_  DXGI_SWAP_CHAIN_DESC *pDesc,
            /* [annotation][out] */ 
            _COM_Outptr_  IDXGISwapChain **ppSwapChain) {
    HRESULT result = g_OldCreateSwapChain(This, pDevice, pDesc, ppSwapChain);

    if(SUCCEEDED(result) && ppSwapChain && *ppSwapChain) {
        g_pSwapChain = *ppSwapChain;
        if(nullptr == g_OldPresent) {
            void **vtable = *(void***)*ppSwapChain;
            g_OldPresent = (Present_t)vtable[8];
            DetourTransactionBegin();
            DetourUpdateThread(GetCurrentThread());
            DetourAttach(&(PVOID&)g_OldPresent, New_Present);
            if(NO_ERROR != DetourTransactionCommit()) ErrorBox("Failed to detour IDXGISwapChain::Present.");
        }
    }

    return result;
}

HRESULT WINAPI New_CreateDXGIFactory(REFIID riid, _COM_Outptr_ void **ppFactory);
HRESULT WINAPI New_CreateDXGIFactory1(REFIID riid, _COM_Outptr_ void **ppFactory);

CAfxImportFuncHook<HRESULT(WINAPI*)(REFIID riid, _COM_Outptr_ void **ppFactory)> g_Import_rendersystemdx11_dxgi_CreateDXGIFactory("CreateDXGIFactory", &New_CreateDXGIFactory);
CAfxImportFuncHook<HRESULT(WINAPI*)(REFIID riid, _COM_Outptr_ void **ppFactory)> g_Import_rendersystemdx11_dxgi_CreateDXGIFactory1("CreateDXGIFactory1", &New_CreateDXGIFactory1);

CAfxImportDllHook g_Import_rendersystemdx11_dxgi("dxgi.dll", CAfxImportDllHooks({
	&g_Import_rendersystemdx11_dxgi_CreateDXGIFactory,
    &g_Import_rendersystemdx11_dxgi_CreateDXGIFactory1
    }));

HRESULT WINAPI New_CreateDXGIFactory(REFIID riid, _COM_Outptr_ void **ppFactory) {
    HRESULT result = g_Import_rendersystemdx11_dxgi_CreateDXGIFactory.GetTrueFuncValue()(riid, ppFactory);

    if(SUCCEEDED(result) && ppFactory && *ppFactory
        && ( __uuidof(IDXGIFactory4) == riid || __uuidof(IDXGIFactory) == riid )
        && nullptr == g_OldCreateSwapChain) {
            void **vtable = *(void***)*ppFactory;
            AfxDetourPtr(&(vtable[10]),New_CreateSwapChain,(PVOID*)&g_OldCreateSwapChain);
        }
        
    return result;
}

HRESULT WINAPI New_CreateDXGIFactory1(REFIID riid, _COM_Outptr_ void **ppFactory) {
    HRESULT result = g_Import_rendersystemdx11_dxgi_CreateDXGIFactory1.GetTrueFuncValue()(riid, ppFactory);

    if(SUCCEEDED(result) && ppFactory && *ppFactory
        && ( __uuidof(IDXGIFactory4) == riid || __uuidof(IDXGIFactory) == riid )
        && nullptr == g_OldCreateSwapChain) {
            void **vtable = *(void***)*ppFactory;
            AfxDetourPtr(&(vtable[10]),New_CreateSwapChain,(PVOID*)&g_OldCreateSwapChain);
        }
        
    return result;
}

typedef bool (__fastcall * CRenderDeviceBase_Present_t)(
    void * This, void * Rdx, void * R8d, void * R9d, void * Stack0, void * Stack1, void * Stack2, void * Stack3, void * Stack4);

CRenderDeviceBase_Present_t g_Old_CRenderDeviceBase_Present = nullptr;


CAfxCapture * g_ActiveCapture = nullptr;

bool __fastcall New_CRenderDeviceBase_Present(
    void * This, void * Rdx, void * R8d, void * R9d, void * Stack0, void * Stack1, void * Stack2, void * Stack3, void * Stack4) {

    g_RenderSystemDrawingData.Push();
    
    g_CampathDrawer.OnEngineThread_EndFrame();

    {
        std::unique_lock<std::mutex> lock(g_SwapChainMutex);
        if(g_ActiveCapture) {
            CAfxCapture * capture = g_ActiveCapture;
            g_SwapchainBeforePresentQueue.push([capture](ID3D11DeviceContext * pDeviceContext, ID3D11Texture2D * pTexture){
                capture->OnBeforeGpuPresent(pDeviceContext, pTexture);
                return false;
            });        
            g_SwapchainAfterPresentQueue.push([capture](ID3D11DeviceContext * pDeviceContext){
                capture->OnAfterGpuPresent(pDeviceContext);
                return false;
            });
        }

        g_SwapchainBeforePresentQueue.push([](ID3D11DeviceContext * pDeviceContext, ID3D11Texture2D * pTexture){
            return true;
        });
        g_SwapchainAfterPresentQueue.push([](ID3D11DeviceContext * pDeviceContext){
            return true;
        });    
    }

    bool result = g_Old_CRenderDeviceBase_Present(This, Rdx, R8d, R9d, Stack0, Stack1, Stack2, Stack3, Stack4);

    return result;
}

std::string g_ViewName("Player 0");
std::string g_ViewPass("GameOverlay");

struct {
    std::shared_timed_mutex m_Mutex;
    std::map<DWORD, ViewPasses_s> m_ThreadToViewPasses;
} g_RenderLayer;

typedef void (__fastcall * Unk_SceneSystem_RenderLayer_t)(void * pThisCSceneSystem,void * param_2,void * pCSceneLayer);
Unk_SceneSystem_RenderLayer_t g_Old_Unk_SceneSystem_RenderLayer = nullptr;
void __fastcall New_Unk_SceneSystem_RenderLayer(void * pThisCSceneSystem,void * param_2,void * pCSceneLayer) {

    int iWaitEventId = *(int*)((unsigned char*)pThisCSceneSystem + 0x30);
    int iLayersLeft = *(int*)((unsigned char*)pThisCSceneSystem+0x48);
    bool bWillSubmitDisplayLists = 2 == iLayersLeft;
    void * pCSceneView = *(void**)((unsigned char *)pCSceneLayer+0x6d0);
    auto fnGetViewLayerName = (const char * (__fastcall *)(void * This))(*(void***)pCSceneView)[0];
    const char * pszViewName = fnGetViewLayerName(pCSceneView);
    const char* pszViewPass = (const char*)pCSceneLayer + 0x4a0;
    unsigned int flags = *(unsigned int *)((unsigned char*)pCSceneLayer + 0x48);
    bool bDepthPassNotShadedPass = 0 != (flags & 0x1000000);
    bool bFullSortNotBatchSort = 0 != (flags & 0x1);

    ViewPass_e viewPass = ViewPass_e::None;
    if(0 == strcmp(pszViewPass, g_ViewPass.c_str()) && 0 == strcmp(pszViewName, g_ViewName.c_str()) && bFullSortNotBatchSort && !bDepthPassNotShadedPass) {
        viewPass = ViewPass_e::BeforeGameOverlay;
    }

    DWORD currentThreadId = 0;
    {
        std::unique_lock<std::shared_timed_mutex> lock(g_RenderLayer.m_Mutex);
        g_RenderLayer.m_ThreadToViewPasses[currentThreadId].Queue.push(viewPass);
    }

    g_Old_Unk_SceneSystem_RenderLayer(pThisCSceneSystem, param_2, pCSceneLayer);
}
/*typedef void(__fastcall* Unk_SceneSystem_SubmitLayers_t)(void* pThisCSceneSystem, void* param_2);
Unk_SceneSystem_SubmitLayers_t g_Old_Unk_SceneSystem_SubmitLayers = nullptr;
void __fastcall New_Unk_SceneSystem_SubmitLayers(void * pThisCSceneSystem,void * param_2) {
    int iBeforeGameOverlayPassCount = -1;
    int passCount = -1;
    {
        std::shared_lock<std::shared_timed_mutex> lock(g_CurrentLayer.m_Mutex);
        auto it = g_CurrentLayer.m_WaitEventIdToViewPasses.find(iWaitEventId);
        if (it != g_CurrentLayer.m_WaitEventIdToViewPasses.end()) {
            auto & viewPasses = it->second;
            while(!viewPasses.Queue.empty()) {
                passCount++;
                if(viewPasses.Queue.front() == ViewPass_e::BeforeGameOverlay) iBeforeGameOverlayPassCount = passCount;
                viewPasses.Queue.pop();
            }
        }
    }

    DWORD currentThreadId;
    if(iBeforeGameOverlayPassCount != -1) {
        currentThreadId = GetCurrentThreadId();
        std::unique_lock<std::shared_timed_mutex> lock(g_CurrentScene.m_Mutex);
        g_CurrentScene.m_ThreadIdToViewPassCount[currentThreadId] = iBeforeGameOverlayPassCount;
    }

    g_Old_Unk_SceneSystem_SubmitLayers(pThisCSceneSystem,param_2);
}*/

typedef unsigned char* (__fastcall* SceneSystem_CreateRenderContextPtr1_t)(unsigned char * param_1, unsigned char param_2, void* pDevice, void * param_4, const char * fmt, ...);
SceneSystem_CreateRenderContextPtr1_t g_Old_SceneSystem_CreateRenderContextPtr1;

extern CConsolePrinter * g_ConsolePrinter;
extern advancedfx::Con_Printf_t Tier0_Message;

class CRenderSystemConsolePrint : public IRenderThreadCallback {
public:
    CRenderSystemConsolePrint(int nr, const char* fmt, va_list args)
        : m_Nr(nr), m_Fmt(fmt)
    {
        size_t m_Print_MemorySize = 0;
        m_Print_Memory = (char*)malloc(sizeof(char) * 63);
        if (nullptr != m_Print_Memory) m_Print_MemorySize = 63;
        else return;
        int chars = vsnprintf(m_Print_Memory, m_Print_MemorySize, fmt, args);
        if (chars < 0) return;
        if (chars >= m_Print_MemorySize) {
            m_Print_Memory = (char*)realloc(m_Print_Memory, sizeof(char) * (chars + 1));
            if (nullptr != m_Print_Memory) m_Print_MemorySize = chars + 1;
            else return;
            vsnprintf(m_Print_Memory, m_Print_MemorySize, fmt, args);
        }
    }

    virtual void OnCallback(void) {
        advancedfx::Message("AFXDEBUG CreateRenderContextPtr%i(%s):%s\n", m_Nr, m_Fmt, m_Print_Memory ? m_Print_Memory : "");
    }

    int m_Nr;
    const char * m_Fmt;
    char* m_Print_Memory = nullptr;

};
/* Typical print on de_mirage:
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#Player 0/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#ParticleSunShadow0/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM0 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM0 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM1 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM1 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM2 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM2 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#CSM3 "(unnamed)" (MIXED)/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSM3 "(unnamed)" (MIXED)/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#Player 0/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(#%s/SetupGpuCull):#Player 0/SetupGpuCull
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Clear Color Depth Stencil/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ParticleShadowsCollectParticle/LayerClear
AFXDEBUG CreateRenderContextPtr2(#%s/SetupView):#Csgo3DSkyboxView/SetupView
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#Csgo3DSkyboxView/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/StencilClear/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets (4)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets (2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(1) Smoke 1/4)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(1) Smoke 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets (1)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(1) Translucent 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(2) Smoke 1/4)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(2) Smoke 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/Translucent Forward (MBOIT(2) Translucent 1/2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/WaterEffects/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/EffectsOpaque/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/EffectsBloom (Pass 2)/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/%s/LayerClear):#Player 0/ClearSmokeTargets/LayerClear
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOHud/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOMainMenu/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOLoadingScreen/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#CSGOPopups/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr1(#%s/SetupLightsAndViewConstants):#PanoramaEngineConsole/SetupLightsAndViewConstants
AFXDEBUG CreateRenderContextPtr2(SubmitAllDisplayLists):SubmitAllDisplayLists
*/

bool g_bRenderContextDebug = false;

unsigned char * __fastcall New_SceneSystem_CreateRenderContextPtr1(unsigned char * param_1, unsigned char param_2, void* pDevice, void * param_4, const char * fmt, ...) {

    // It would be possible to pass vararg on with asm trampoline, but it seems unused?
    unsigned char * result = g_Old_SceneSystem_CreateRenderContextPtr1(param_1,param_2,pDevice,param_4,"Hooked by HLAE / advancedfx.org, if you happen to actually see this please file a bug report, please!");

    //TODO: string comparison is expensive, consider to check string address instead.

    if(g_bRenderContextDebug) {
        const char * saveFmt = fmt ? fmt : "[nullptr]";

        if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
            auto fnQueueCallback = (void(__fastcall*)(void* pCRenderConStextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
            va_list args;
            va_start(args, fmt);
            fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CRenderSystemConsolePrint(1, saveFmt,args));
            va_end(args);
        }
    }

    if (fmt && 0 == strcmp("#%s/%s/LayerClear", fmt)) {
        va_list args;
        va_start(args, fmt);
        const char * pszArg0 = va_arg(args, const char *);
        const char * pszArg1 = va_arg(args, const char *);
        if(pszArg0 && 0 == strcmp("Player 0",pszArg0) && pszArg1) {
            if (0 == strcmp("Translucent Forward (MBOIT(2) Translucent 1/2)", pszArg1)) {
                if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                    auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                    fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackBeforeClearSmokeTargets1());
                }
            }
            /*else if (0 == strcmp("ClearSmokeTargets (4)", pszArg1)) {
                if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                    auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                    fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackAfterClearSmokeTargets1());
                }
            }*/
            else if (0 == strcmp("WaterEffects", pszArg1)
                || 0 == strcmp("Decals Translucent Depth", pszArg1)) {
                if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                    auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                    fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderCallbackAfterMaybeSmokeDrawn());
                }
            }

        }
    }  
    else if(fmt && 0 == strcmp("#%s/SetupLightsAndViewConstants",fmt)) {
        /*va_list args;
        va_start(args, fmt);
        const char * pszArg0 = va_arg(args, const char *);
        if(pszArg0 && 0 == strcmp("Player 0",pszArg0)) {
            if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderViewCallback());
            }
        }*/
        va_list args;
        va_start(args, fmt);
        const char * pszArg0 = va_arg(args, const char *);
        if(pszArg0 && 0 == strcmp("CSGOHud",pszArg0)) {
            if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
                auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
                fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderViewCallback());
            }
        }
    }


    return result;
}

typedef unsigned char* (__fastcall* SceneSystem_CreateRenderContextPtr2_t)(unsigned char* param_1, unsigned char param_2, void* pDevice, const char * fmt, ...);
SceneSystem_CreateRenderContextPtr2_t g_Old_SceneSystem_CreateRenderContextPtr2 = nullptr;
unsigned char * __fastcall New_SceneSystem_CreateRenderContextPtr2(unsigned char *param_1,unsigned char param_2, void* pDevice, const char * fmt, ...) {

    // It would be possible to pass vararg on with asm trampoline, but it seems unused?
    unsigned char * result = g_Old_SceneSystem_CreateRenderContextPtr2(param_1, param_2,pDevice,"Hooked by HLAE / advancedfx.org, if you happen to actually see this please file a bug report, please!");

/*    if (pContextName && 0 == strcmp(pContextName, "#%s/SetupView")) {
        if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
            auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
            fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderViewCallback());
        }
    }
*/
    if(g_bRenderContextDebug) {
        const char * saveFmt = fmt ? fmt : "[nullptr]";

        if (void* pCRenderContextDx11_SoftwareCommandList = *(void**)param_1) {
            auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
            va_list args;
            va_start(args, fmt);
            fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CRenderSystemConsolePrint(2, saveFmt, args));
            va_end(args);
        }
    }

    return result;
}

/*
std::string g_ObjectDesc("<unknown>");

void On_CSceneSystem_RenderQueueElement(void * pCSceneObjectDesc, void * pCRenderContextDx11_SoftwareCommandList) {
           
    auto fnGetSceneObjectName = (const char* (__fastcall*)(void* pCSceneObjectDesc))(*(void***)pCSceneObjectDesc)[0];
    const char * pszSceneObjectName = fnGetSceneObjectName(pCSceneObjectDesc);
    advancedfx::Message("AFX: RenderQueueElement: %s\n",pszSceneObjectName);

    if (0 == strcmp(pszSceneObjectName, g_ObjectDesc.c_str())) {
        auto fnQueueCallback = (void(__fastcall*)(void* pCRenderContextDx11_SoftwareCommandList, void* pCallback))(*(void***)pCRenderContextDx11_SoftwareCommandList)[134];
        fnQueueCallback(pCRenderContextDx11_SoftwareCommandList, new CAfxRenderViewCallback());
    }

    // Execute the original function call we detoured:
    auto fnRenderElement = (void(__fastcall*)(void* This, void* pCRenderContextDx11_SoftwareCommandList))(*(void***)pCSceneObjectDesc)[10];
    fnRenderElement(pCSceneObjectDesc, pCRenderContextDx11_SoftwareCommandList);
}
*/
CAfxImportsHook g_Import_rendersystemdx11(CAfxImportsHooks({
	&g_Import_rendersystemdx11_dxgi
    }));

#define STRINGIZE(x) STRINGIZE2(x)
#define STRINGIZE2(x) #x
#define MkErrStr(file,line) "Problem in " file ":" STRINGIZE(line)

void Hook_RenderSystemDX11(void * hModule) {
    static bool firstRun = true;

    if(firstRun) {
        firstRun = false;

        if(g_Import_rendersystemdx11.Apply((HMODULE)hModule)) {
            // We have to detour it in-place, because it can be called from elsewhere:
            if(HMODULE hD3D11Dll = GetModuleHandleA("d3d11.dll")) {
                if(g_Old_D3D11CreateDevice = (D3D11CreateDevice_t)GetProcAddress(hD3D11Dll,"D3D11CreateDevice")) {
                    DetourTransactionBegin();
                    DetourUpdateThread(GetCurrentThread());
                    DetourAttach(&(PVOID&)g_Old_D3D11CreateDevice, New_D3D11CreateDevice);
                    if(NO_ERROR == DetourTransactionCommit()) {
                    } else ErrorBox("Failed to hook D3D11CreateDevice.");
                } else ErrorBox("Failed to get D3D11CreateDevice address.");
            } else ErrorBox("Failed to get d3d11.dll module handle.");
        } else ErrorBox("Failed rendersystemdx11 import hooks.");

        Afx::BinUtils::MemRange textRange = Afx::BinUtils::MemRange::FromEmpty();
        Afx::BinUtils::MemRange dataRange = Afx::BinUtils::MemRange::FromEmpty();
        {
            Afx::BinUtils::ImageSectionsReader sections((HMODULE)hModule);
            if(!sections.Eof()) {
                textRange = sections.GetMemRange();
                sections.Next();
                if(!sections.Eof()){
                    dataRange = sections.GetMemRange();
                }
            }
        }

        // CRenderDeviceBase::Present
        //
        // Function jmps into a function that references string "CRenderDeviceBase::Present(640):".
        if(void ** vtable = (void**)Afx::BinUtils::FindClassVtable((HMODULE)hModule,".?AVCRenderDeviceDx11@@", 0, 0x0)) {
            AfxDetourPtr(&(vtable[16]),New_CRenderDeviceBase_Present,(PVOID*)&g_Old_CRenderDeviceBase_Present);
        } else ErrorBox(MkErrStr(__FILE__, __LINE__));
    }

}

void Hook_SceneSystem(void * hModule) {
    static bool firstRun = true;

    if(firstRun) {
        firstRun = false;

		Afx::BinUtils::ImageSectionsReader sections((HMODULE)hModule);
		Afx::BinUtils::MemRange textRange = sections.GetMemRange();

        // See FUN_1800f1b30 doc/notes_cs2/sc_dump_lists.txt.
        {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "48 8b c4 4c 89 40 18 48 89 50 10 48 89 48 08 55 53 57 48 8d a8 08 fe ff ff 48 81 ec e0 02 00 00");
            if (!result.IsEmpty()) {
                g_Old_Unk_SceneSystem_RenderLayer = (Unk_SceneSystem_RenderLayer_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_Unk_SceneSystem_RenderLayer, New_Unk_SceneSystem_RenderLayer);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }

        // See FUN_1800f8780 doc/notes_cs2/sc_dump_lists.txt.
        /* {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "48 89 5c 24 10 55 56 57 41 54 41 55 41 56 41 57 48 8d 6c 24 d9 48 81 ec a0 00 00 00 4c 8b fa 48 8b d9 e8 ?? ?? ?? ??");
            if (!result.IsEmpty()) {
                g_Old_Unk_SceneSystem_SubmitLayers = (Unk_SceneSystem_SubmitLayers_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_Unk_SceneSystem_SubmitLayers, New_Unk_SceneSystem_SubmitLayers);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }*/

        // First reference to "WARNING: Trying to create a CRenderContextPtr without a valid context.\n"
        {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "40 53 56 57 48 83 ec 20 49 8b 00 49 8b d8 48 8b f9 45 33 c0 48 8b cb 49 8b f1 ff 90 e0 01 00 00");
            if (!result.IsEmpty()) {
                g_Old_SceneSystem_CreateRenderContextPtr1 = (SceneSystem_CreateRenderContextPtr1_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_SceneSystem_CreateRenderContextPtr1, New_SceneSystem_CreateRenderContextPtr1);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }

        // See FUN_18004aff0 doc/notes_cs2/sc_dump_lists.txt.
        // Second reference to "WARNING: Trying to create a CRenderContextPtr without a valid context.\n"
        {
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "40 55 53 57 48 8d 6c 24 b9 48 81 ec a0 00 00 00 80 65 3d fe 33 c0 49 8b d8 48 89 45 c7 48 89 45 0f 48 8b f9 89 45 2f 48 8b cb 48 89 45 cf 48 89 45 d7 48 89 45 17 48 89 45 df 48 89 45 e7 48 89 45 1f 48 89 45 33 48 89 45 ef 48 89 45 f7 48 89 45 27 48 89 45 ff 48 89 45 07 66 89 45 3b 49 8b 00 45 33 c0 ff 90 e0 01 00 00");
            if (!result.IsEmpty()) {
                g_Old_SceneSystem_CreateRenderContextPtr2 = (SceneSystem_CreateRenderContextPtr2_t)result.Start;	
                DetourTransactionBegin();
                DetourUpdateThread(GetCurrentThread());
                DetourAttach(&(PVOID&)g_Old_SceneSystem_CreateRenderContextPtr2, New_SceneSystem_CreateRenderContextPtr2);
                if(NO_ERROR != DetourTransactionCommit())
                    ErrorBox(MkErrStr(__FILE__, __LINE__));
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }
        

        // See "WE WANT TO DETOUR ABOUT HERE" in FUN_1800f8780 in doc/notes_cs2/sc_dump_lists.txt.
        /*
                             LAB_1800f8a80                                   XREF[1]:     1800f8af7(j)  
       1800f8a80 8b c7           MOV        EAX,EDI
       1800f8a82 48 c1 e8 10     SHR        RAX,0x10
       1800f8a86 48 8d 0c 40     LEA        RCX,[RAX + RAX*0x2]
       1800f8a8a 48 8b 83        MOV        RAX,qword ptr [RBX + 0xb10]
                 10 0b 00 00
       1800f8a91 48 8d 14 c8     LEA        RDX,[RAX + RCX*0x8]
       1800f8a95 0f b7 cf        MOVZX      ECX,DI
       1800f8a98 48 8b 42 08     MOV        RAX,qword ptr [RDX + 0x8]
       1800f8a9c 48 03 c9        ADD        RCX,RCX
// BEGIN DETOUR       
       1800f8a9f 48 8b d6        MOV        RDX,RSI
       1800f8aa2 48 8b 4c        MOV        RCX,qword ptr [RAX + RCX*0x8 + 0x8]
                 c8 08
       1800f8aa7 48 8b 01        MOV        RAX,qword ptr [RCX]
       1800f8aaa ff 50 50        CALL       qword ptr [RAX + 0x50]
// END DETOUR
       1800f8aad 4c 63 8b        MOVSXD     R9,dword ptr [RBX + 0xb08]
                 08 0b 00 00        
        */
        /*{
            Afx::BinUtils::MemRange result = FindPatternString(textRange, "8b c7 48 c1 e8 10 48 8d 0c 40 48 8b 83 10 0b 00 00 48 8d 14 c8 0f b7 cf 48 8b 42 08 48 03 c9 48 8b d6 48 8b 4c c8 08 48 8b 01 ff 50 50 4c 63 8b 08 0b 00 00");
            if (!result.IsEmpty()) {
                MdtMemBlockInfos mbis;
                MdtMemAccessBegin((LPVOID)(result.Start+0x1f), 14, &mbis);

                static LPVOID ptr2 = On_CSceneSystem_RenderQueueElement;
                LPVOID ptrPtr2 = &ptr2;
                size_t pCallAddress3 = result.Start+0x1f+14;
                static LPVOID ptr3 = (LPVOID)pCallAddress3;
                LPVOID ptrPtr3 = &ptr3;
                unsigned char asmCode2[32]={
                    0x48, 0x8b, 0xd6,               // MOV        RDX,RSI
                    0x48, 0x8b, 0x4c, 0xc8, 0x08,   // MOV        RCX,qword ptr [RAX + RCX*0x8 + 0x8]

				    0x48, 0xb8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // mov rax, qword addr
				    0xff, 0x10, // call    qword ptr [rax] // call our function

                    0x48, 0xb8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // mov rax, qword addr
                    0xff, 0x20 // jmp [rax] // back to where to continue
                };
                memcpy(&asmCode2[10], &ptrPtr2, sizeof(LPVOID));
                memcpy(&asmCode2[22], &ptrPtr3, sizeof(LPVOID));

                LPVOID pTrampoline = MdtAllocExecuteableMemory(32);
                memcpy(pTrampoline, asmCode2, 32);

                unsigned char asmCode[14]={
                    0x48, 0xba, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // mov rdx, qword addr
                    0xff, 0x22, // jmp [rdx]
                    0x90, // nop
                    0x90 // nop
                };
                static LPVOID ptr = pTrampoline;
                LPVOID ptrPtr = &ptr;
                memcpy(&asmCode[2], &ptrPtr, sizeof(LPVOID));

                memcpy((LPVOID)(result.Start+0x1f), asmCode, 14);
                MdtMemAccessEnd(&mbis);
            }
            else
                ErrorBox(MkErrStr(__FILE__, __LINE__));
        }*/
    }
}

void EndCapture() {
    if(g_ActiveCapture) {
        CAfxCapture * capture = g_ActiveCapture;
        {
            std::unique_lock<std::mutex> lock(g_SwapChainMutex);
            g_SwapchainAfterPresentQueue.push([capture](ID3D11DeviceContext * pDeviceContext){
                capture->Finish(pDeviceContext);
                delete capture;
                return false;
            });
        }
        g_ActiveCapture = nullptr;
    }
}

void CreateCapture(class advancedfx::COutVideoStreamCreator* pOutVideoStreamCreator) {
    EndCapture();
    g_ActiveCapture = new CAfxCapture(pOutVideoStreamCreator);
}

advancedfx::CImageBufferPoolThreadSafe g_ImageBufferPool;

class CAfxStreams : public advancedfx::IRecordStreamSettings {
public:
    bool m_CampathAutoSave = false;
	bool m_CamExport = false;
	bool m_CamExportSet = false;

    bool GetCampathAutosave() { return m_CampathAutoSave; }
    void SetCampathAutosave(bool value) { m_CampathAutoSave = value; }

	bool CamExport_get(void) { return m_CamExport;  }
	void CamExport_set(bool value) { m_CamExport = value;  }

    CAfxStreams() {
        m_RecordScreen = new CRecordScreen(false, advancedfx::CRecordingSettings::GetDefault());        
    }

	void ShutDown(void) {
        if(m_Shutdown) return;
        m_Shutdown = true;
		delete m_RecordScreen;
    }    

    ~CAfxStreams(){
        ShutDown();
    }

    const char* GetRecordName() {
        return m_RecordName.c_str();
    }

    void SetRecordName(const char * value) {
        m_RecordName = value;
    }

    bool GetStartMovieWav() {
        return m_StartMovieWav;
    }

    void SetStartMovieWav(bool value) {
        m_StartMovieWav = value;
    }

    bool GetOverrideFps() {
        return m_OverrideFps;
    }

    void SetOverrideFps(bool value) {
        m_OverrideFps = value;
    }

    float GetOverrideFpsValue() {
        return m_OverrideFpsValue;
    }

    void SetOverrideFpsValue(float value) {
        m_OverrideFpsValue = value;
    }

	virtual bool GetStreamFolder(std::wstring& outFolder) const {
        outFolder = m_TakeDir;
        return true;
    }

    const wchar_t * GetTakeDir(void) const {
        return m_TakeDir.c_str();
    }

	virtual advancedfx::StreamCaptureType GetCaptureType() const {
        return m_StreamCaptureType;
    }

    virtual advancedfx::IImageBufferPool * GetImageBufferPool() const {
        return &g_ImageBufferPool;
    }

    virtual bool GetFormatBmpNotTga() const {        
        return m_FormatBmpAndNotTga;
    }

    void SetFormatBmpNotTga(bool value) {
        m_FormatBmpAndNotTga = value;
    }

    void Console_RecordScreen(advancedfx::ICommandArgs* args);

    void RecordStart();
    void RecordEnd();

    bool GetRecording() { return m_Recording; }

private:
    bool m_Shutdown = false;
    advancedfx::StreamCaptureType m_StreamCaptureType = advancedfx::StreamCaptureType::Normal;
    bool m_FormatBmpAndNotTga = false;
    bool m_StartMovieWav = true;
    bool m_OverrideFps = false;
    float m_OverrideFpsValue = 60.0;
    std::string m_RecordName = "untitled_rec";
    
	class CRecordScreen {
	public:
		bool Enabled;
		advancedfx::CRecordingSettings* Settings;

		CRecordScreen(bool enabled, advancedfx::CRecordingSettings* settings)
			: Enabled(enabled)
			, Settings(settings)
		{
			settings->AddRef();
		}

		CRecordScreen(const CRecordScreen& other)
		: Enabled(other.Enabled)
		, Settings(other.Settings) {
			Settings->AddRef();
		}

		~CRecordScreen() {
			Settings->Release();
		}
	};
	CRecordScreen* m_RecordScreen;

    bool m_Recording = false;
    std::wstring m_TakeDir;
    bool m_StartMovieWavUsed = false;
    float m_StartHostFrameRateValue = 60.0;
    
    bool m_UsedHostFramerRateValue = false;
    float m_OldValue_host_framerate;
    bool m_OldValue_r_always_render_all_windows;
    int m_OldValue_engine_no_focus_sleep;
} g_AfxStreams;

void CAfxStreams::Console_RecordScreen(advancedfx::ICommandArgs* args) {
	int argC = args->ArgC();
	char const* arg0 = args->ArgV(0);

	if (2 <= argC)
	{
		char const* arg1 = args->ArgV(1);
		if (0 == _stricmp(arg1, "enabled")) {
			if (3 <= argC) {
				m_RecordScreen->Enabled = 0 != atoi(args->ArgV(2));
				return;
			}

			advancedfx::Message(
				"%s enabled 0|1 - Disable (0, default) or enable (1) game screen recording.\n"
				"Current value: %i\n"
				, arg0
				, (m_RecordScreen->Enabled?1:0)
			);
			return;
		}
		if (0 == _stricmp(arg1, "settings")) {
			if (3 <= argC)
			{
				char const* arg2 = args->ArgV(2);

				if (advancedfx::CRecordingSettings* settings = advancedfx::CRecordingSettings::GetByName(arg2))
				{
					settings->AddRef();
					m_RecordScreen->Settings->Release();
					m_RecordScreen->Settings = settings;
				}
				else
				{
					advancedfx::Warning("AFXERROR: There is no recording setting named %s\n", arg2);
				}

				return;
			}

			advancedfx::Message(
				"%s settings <name> - Set recording settings to use from mirv_streams settings.\n"
				"Current value: %s\n"
				, arg0
				, m_RecordScreen->Settings->GetName()
			);

			return;
		}
	}

	advancedfx::Message(
		"%s enabled [...] - Enables / disables screen recording.\n"
		"%s settings [...] - Controls recording settings.\n"
		, arg0
		, arg0
	);
}

void AfxHookSourceRs_Engine_OnRecordStart(const char * take_folder_path);

extern CamPath g_CamPath;

void CAfxStreams::RecordStart()
{
	RecordEnd();

	advancedfx::Message("Starting recording ... ");
	
	if(UTF8StringToWideString(m_RecordName.c_str(), m_TakeDir)
		&& (m_TakeDir.append(L"\\take"), SuggestTakePath(m_TakeDir.c_str(), 4, m_TakeDir))
		&& CreatePath(m_TakeDir.c_str(), m_TakeDir)
	)
	{
		m_Recording = true;
		m_StartMovieWavUsed = false;

		std::string utf8TakeDir;
		bool utf8TakeDirOk = WideStringToUTF8String(m_TakeDir.c_str(), utf8TakeDir);
        SOURCESDK::CS2::Cvar_s * handle_host_framerate = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("host_framerate", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_engine_no_focus_sleep = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("engine_no_focus_sleep", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_r_always_render_all_windows = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("r_always_render_all_windows", false).Get());
        
        m_UsedHostFramerRateValue = GetOverrideFps();

        if(m_UsedHostFramerRateValue && handle_host_framerate) {
            m_OldValue_host_framerate = handle_host_framerate->m_Value.m_flValue;
            handle_host_framerate->m_Value.m_flValue = GetOverrideFpsValue();
        }

        if(handle_engine_no_focus_sleep) {
            m_OldValue_engine_no_focus_sleep = handle_engine_no_focus_sleep->m_Value.m_i32Value;
            handle_engine_no_focus_sleep->m_Value.m_i32Value = 0;
        }

        if(handle_r_always_render_all_windows) {
            m_OldValue_r_always_render_all_windows = handle_r_always_render_all_windows->m_Value.m_bValue;
            handle_r_always_render_all_windows->m_Value.m_bValue = true;
        }

		float host_framerate = m_OverrideFps ? m_OverrideFpsValue : (handle_host_framerate != nullptr ? m_OldValue_host_framerate : 0);
		double frameTime;
		if (1.0 <= host_framerate) {
			m_StartHostFrameRateValue = host_framerate;
			frameTime = 1.0 / host_framerate;
		}
		else {
			m_StartHostFrameRateValue = host_framerate ? 1.0f / host_framerate : 0.0f;
			frameTime = host_framerate;
		}

		if (0 == frameTime) {
			advancedfx::Warning("You probably forgot to set host_framerate to the FPS you want to record.\n");
			if (nullptr == handle_host_framerate) {
				advancedfx::Warning("You probably forgot to set mirv_streams record fps to the FPS you want to record.\n");
			}
		}

		if(m_CampathAutoSave && 0 < g_CamPath.GetSize())
		{
			std::wstring campathFileName(m_TakeDir);
			campathFileName.append(L"\\campath.xml");
			if(!g_CamPath.Save(campathFileName.c_str()))
				advancedfx::Warning("Error: Failed saving campath.xml to take folder.\n");
		}        

		if (m_CamExport)
		{
			std::wstring camFileName(m_TakeDir);
			camFileName.append(L"\\cam_main.cam");

			m_CamExportSet = true;
			g_S2CamIO.SetCamExport(new CamExport(camFileName.c_str()));
		}

		if(m_RecordScreen->Enabled) {
			CreateCapture(
				m_RecordScreen->Settings->CreateOutVideoStreamCreator(
					*this,
					*this,
					m_StartHostFrameRateValue,
					""
				)
			);
		}

		advancedfx::Message("done.\n");

		advancedfx::Message("Recording to \"%s\".\n", utf8TakeDirOk ? utf8TakeDir.c_str() : "?");

		m_StartMovieWavUsed = m_StartMovieWav;

		if (m_StartMovieWavUsed)
		{
            SOURCESDK::CS2::ConCommandHandle handle_startmovie = SOURCESDK::CS2::g_pCVar->FindCommand( "startmovie", false );
            if(handle_startmovie.IsValid()) {
                const char * pszArgs[3] = {"startmovie",ADVANCEDFX_STARTMOVIE_WAV_KEY,"wav"};
                SOURCESDK::CS2::g_pCVar->DispatchConCommand(handle_startmovie, SOURCESDK::CS2::CCommandContext(SOURCESDK::CS2::CT_FIRST_SPLITSCREEN_CLIENT,0), SOURCESDK::CS2::CCommand(3,pszArgs));
            } else advancedfx::Warning("AFXERROR: startmovie command not found, wav recording not possible.");
		}

        AfxHookSourceRs_Engine_OnRecordStart(utf8TakeDirOk ? utf8TakeDir.c_str() : nullptr);
	}
	else
	{
		advancedfx::Message("FAILED");
		advancedfx::Warning("Error: Failed to create directories for \"%s\".\n", m_RecordName.c_str());
	}

}


void AfxHookSourceRs_Engine_OnRecordEnd();

void CAfxStreams::RecordEnd()
{
	if(m_Recording)
	{
        AfxHookSourceRs_Engine_OnRecordEnd();

		advancedfx::Message("Finishing recording ... ");
		if (m_StartMovieWavUsed)
		{
            SOURCESDK::CS2::ConCommandHandle handle_endmovie = SOURCESDK::CS2::g_pCVar->FindCommand( "endmovie", false );
            if(handle_endmovie.IsValid()) {
                const char * pszArgs[1] = {"endmovie"};
                SOURCESDK::CS2::g_pCVar->DispatchConCommand(handle_endmovie, SOURCESDK::CS2::CCommandContext(SOURCESDK::CS2::CT_FIRST_SPLITSCREEN_CLIENT,0), SOURCESDK::CS2::CCommand(1,pszArgs));
            } else advancedfx::Warning("AFXERROR: endmovie command not found, stopping the wav recording not possible.");

		}

		if(m_CamExportSet) {
			m_CamExportSet = false;
			g_S2CamIO.SetCamExport(nullptr);
		}

		if(m_RecordScreen->Enabled) {
            EndCapture();
		}

        SOURCESDK::CS2::Cvar_s * handle_host_framerate = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("host_framerate", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_engine_no_focus_sleep = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("engine_no_focus_sleep", false).Get());
        SOURCESDK::CS2::Cvar_s * handle_r_always_render_all_windows = SOURCESDK::CS2::g_pCVar->GetCvar(SOURCESDK::CS2::g_pCVar->FindConVar("r_always_render_all_windows", false).Get());

        if(m_UsedHostFramerRateValue && handle_host_framerate) {
            handle_host_framerate->m_Value.m_flValue = m_OldValue_host_framerate;
        }

        if(handle_engine_no_focus_sleep) {
            handle_engine_no_focus_sleep->m_Value.m_i32Value = m_OldValue_engine_no_focus_sleep;
        }

        if(handle_r_always_render_all_windows) {
            handle_r_always_render_all_windows->m_Value.m_bValue = m_OldValue_r_always_render_all_windows;
        }

    	advancedfx::Message("done.\n");
	}

	m_Recording = false;
}

bool AfxStreams_IsRcording() {
    return g_AfxStreams.GetRecording();
}
const wchar_t * AfxStreams_GetTakeDir() {
    return g_AfxStreams.GetTakeDir();
}

void RenderSystemDX11_SupplyProjectionMatrix(const SOURCESDK::VMatrix & projectionMatrix) {
    g_RenderSystemDrawingData.SetProjectionMatrix(projectionMatrix);
}

CON_COMMAND(mirv_streams, "Access to streams system.")
{
    int argC = args->ArgC();
    const char * cmd0 = args->ArgV(0);

    if(2 <= argC)
    {
        const char * cmd1 = args->ArgV(1);
		if(0 == _stricmp(cmd1, "record"))
		{
			if(3 <= argC)
			{
				char const * cmd2 = args->ArgV(2);

				if(!_stricmp(cmd2, "name"))
				{
					if(4 <= argC)
					{
						char const * cmd3 = args->ArgV(3);
						g_AfxStreams.SetRecordName(cmd3);
						return;
					}

					advancedfx::Message(
						"mirv_streams record name <name> - Set record name to <name>.\n"
						"Current value: %s.\n",
						g_AfxStreams.GetRecordName()
					);
					return;
				}
				else
				if(!_stricmp(cmd2, "start"))
				{
					g_AfxStreams.RecordStart();
					return;
				}
				else
				if(!_stricmp(cmd2, "end"))
				{
					g_AfxStreams.RecordEnd();
					return;
				}
				else
				if(!_stricmp(cmd2, "format"))
				{
					if(4 <= argC)
					{
						char const * cmd3 = args->ArgV(3);

                        if(0 == _stricmp(cmd3, "bmp")) g_AfxStreams.SetFormatBmpNotTga(true);
                        else if(0 == _stricmp(cmd3, "tga")) g_AfxStreams.SetFormatBmpNotTga(false);
                        else advancedfx::Warning("Error: Invalid format %s\n.", cmd3);

						return;
					}

					advancedfx::Message(
						"mirv_streams record format tga|bmp - Set record format to tga or bmp.\n"
						"Current value: %s.\n",
						g_AfxStreams.GetFormatBmpNotTga() ? "bmp" : "tga"
					);
					return;
				}
				else if (0 == _stricmp(cmd2, "screen"))
				{
					advancedfx::CSubCommandArgs subArgs(args, 3);

					g_AfxStreams.Console_RecordScreen(&subArgs);
					return;
				}
				else
				if (!_stricmp(cmd2, "startMovieWav"))
				{
					if (4 <= argC)
					{
						char const * cmd3 = args->ArgV(3);
						g_AfxStreams.SetStartMovieWav(0 != atoi(cmd3));
						return;
					}

					advancedfx::Message(
						"mirv_streams record startMovieWav 0|1 - Whether to record WAV audio (1) or not (0).\n"
						"Current value: %s.\n",
						g_AfxStreams.GetStartMovieWav() ? "1" : "0"
					);
					return;
				}
				else if (!_stricmp(cmd2, "fps")) {
					if (4 <= argC)
					{
						char const* cmd3 = args->ArgV(3);
						if (0 == _stricmp(cmd3, "default")) {
							g_AfxStreams.SetOverrideFps(false);
							return;
						}
						else if (!StringIsAlphas(cmd3)) {
							g_AfxStreams.SetOverrideFpsValue((float)atof(cmd3));
							g_AfxStreams.SetOverrideFps(true);
							return;
						}
					}

					advancedfx::Message(
						"mirv_streams record fps default|<fValue>\n"
					);
					if (g_AfxStreams.GetOverrideFps()) {
						advancedfx::Message(
							"Current value: %f\n", g_AfxStreams.GetOverrideFpsValue()
						);
					}
					else {
						advancedfx::Message(
							"Current value: default\n"
						);
					}
					return;
				}
                else if (!_stricmp(cmd2, "campath"))
				{
					char const* cmd3 = args->ArgV(3);
					if (4 <= argC)
    				{
      				    char const * cmd3 = args->ArgV(3);
            			if (!_stricmp("enabled", cmd3))
            			{
              				if (5 <= argC)
             				{
                				char const * cmd4 = args->ArgV(4);
               					g_AfxStreams.SetCampathAutosave(0 != atoi(cmd4));
                				return;
              				}

              				advancedfx::Message(
                				"mirv_streams record campath enabled 0|1 - Disable (0) or enable (1).\n"
                				"Current value: %i\n", g_AfxStreams.GetCampathAutosave() ? 1 : 0
              				);

              				return;
            			} 
       				}		
          			advancedfx::Message(
           				"mirv_streams record campath enabled [...]\n"
          			);
          			return;
				}
				else if (!_stricmp(cmd2, "cam"))
				{
					char const* cmd3 = args->ArgV(3);
					if (4 <= argC)
    				{
      				    char const * cmd3 = args->ArgV(3);
            			if (!_stricmp("enabled", cmd3))
            			{
              				if (5 <= argC)
             				{
                				char const * cmd4 = args->ArgV(4);
               					g_AfxStreams.CamExport_set(0 != atoi(cmd4));
                				return;
              				}

              				advancedfx::Message(
                				"mirv_streams record cam enabled 0|1 - Disable (0) or enable (1).\n"
                				"Current value: %i\n", g_AfxStreams.CamExport_get() ? 1 : 0
              				);

              				return;
            			} 
       				}		
          			advancedfx::Message(
           				"mirv_streams record cam enabled [...]\n"
          			);
          			return;
				}
			}

			advancedfx::Message(
				"mirv_streams record name [...] - Set/get record name.\n"
				"mirv_streams record start - Begin recording.\n"
				"mirv_streams record end - End recording.\n"
				"mirv_streams record format [...] - Set/get file format.\n"
				"mirv_streams record fps [...] - Allows to override input FPS for games where we can not detect it (not needed for CS:GO).\n"
			);
			advancedfx::Message(
				"mirv_streams record screen [...] - Controls capturing the game content drawn to screen right before being presented.\n"
				"mirv_streams record startMovieWav [...] - Controls WAV audio recording.\n"
			);
			advancedfx::Message(
				"mirv_streams record cam [...] - Controls the camera motion data capture output (can be imported with mirv_camio).\n"
                "mirv_streams record campath [...] - Save current campath into take folder (if not empty).\n"
			);
			return;
		}
		else if (0 == _stricmp("settings", cmd1))
		{
			advancedfx::CSubCommandArgs subArgs(args, 2);
			advancedfx::CRecordingSettings::Console(&subArgs);
			return;
		}        
    }

	advancedfx::Message(
		"mirv_streams record [...] - Recording control.\n"
	);

	advancedfx::Message(
		"mirv_streams settings [...] - Recording settings.\n"
    );
}

CON_COMMAND(mirv_reshade, "Control ReShade_advancedfx ReShade addon.")
{
    if (!g_ReShadeAdvancedfx.IsConnected()) {
        advancedfx::Warning("AFXERROR: ReShade or ReShade_advancedfx.addon not loaded.\n");
        return;
    }

    static bool bEnableReshade = true;
    int argc = args->ArgC();
    const char * cmd0 = args->ArgV(0);

    if (2 <= argc)
    {
        char const* cmd1 = args->ArgV(1);

        if (0 == _stricmp("enabled", cmd1)) {
            if (3 <= argc) {
                bool bDoEnableReShade = 0 != atoi(args->ArgV(2));
                bEnableReshade = bDoEnableReShade;
                g_SwapchainAfterPresentQueue.push([bDoEnableReShade](ID3D11DeviceContext * pDeviceContext){
                    g_bEnableReShade = bDoEnableReShade;
                    return false;
                });   
                return;
            }

            advancedfx::Message(
                "%s enabled 0|1 - Enable / disable reshade addon.\n"
                "Current value: %s\n"
                , cmd0
                , bEnableReshade ? "1" : "0"
            );
            return;
        }
    }

    advancedfx::Message(
        "%s enabled [...].\n"
        , cmd0
    );
}

/*CON_COMMAND(__mirv_test_object_desc, "")
{
    if(2<= args->ArgC()) {
        g_ObjectDesc = args->ArgV(1);
    }
}*/

/*CON_COMMAND(__mirv_test_20250125, "")
{
    if(3<= args->ArgC()) {
        g_ViewName = args->ArgV(1);
        g_ViewPass = args->ArgV(2);
    }
}*/

CON_COMMAND(__mirv_debug_scenesystem_rendercontexts, "")
{
    int argc = args->ArgC();
    const char * cmd0 = args->ArgV(0);

    if(2 <= argc) {
        g_bRenderContextDebug = 0 != atoi(args->ArgV(1));
        return;
    }

    advancedfx::Message(
        "%s 0|1\n"
        "Current value: %i\n"
        , cmd0, g_bRenderContextDebug ? 1 : 0);
}
